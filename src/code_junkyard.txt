CardInside Interface stuff
public int[] getUber(){
int[] u = new int[]{uberAtkATK,uberAtkDEF};
return u;
}
public int[] getAtk(){
int[] a = new int[]{attackATK, attackDEF};
return a;
}
public int[] getCDef(){
int[] cd = new int[]{coreDefATK, coreDefATK};
return cd;
}
public int[] getCore(){
int[] c = new int[]{coreATK, coreDEF};
return c;
}
public int[] getDef(){
int[] d = new int[]{defenceATK,defenceDEF};
return d;
}
public int[] getUber();
public int[] getAtk();
public int[] getCDef();
public int[] getCore();
public int[] getDef();

public int activeStats(Board pos);
public String activeType();

public void coreSkill(){
}
public void skill(){
}

Board
public class Board {

//play method stuff
// while(attackPhase){
// System.exit(130);
// }

package Game;

import java.util.ArrayList;

public class CardSlots {
private final String name;
private final int openSlots;
public ArrayList<Card> slot = new ArrayList<>();

public CardSlots(String Name, int oSlots) {
name = Name;
openSlots = oSlots;
}

public int[] getStats(int slotNum) {
int[] test = new int[]{0, 1};
if (name.equals("uber")) {
return slot.get(slotNum).getUber();
}
if (name.equals("attack")) {
return slot.get(slotNum).getAtk();

}
if (name.equals("core defence")) {
return slot.get(slotNum).getCDef();

}
if (name.equals("core")) {
return slot.get(slotNum).getCore();

}
if (name.equals("defence")) {
return slot.get(slotNum).getDef();

}

return test;
}

public int getOpenSlots() {
return openSlots;
}

public String toString() {
return slot.toString();
}

}
package Game.Slots;
import Game.Card;

public interface CardSlots {
int[] getStats(Card in);
int getAtk(int n);
int getDef(int n);
int showOpenSlots();
}

public void makeBoard() {
Board.add(new CardSlots("uber", 3));
Board.add(new CardSlots("attack", 2));
Board.add(new CardSlots("core defence", 3));
Board.add(new CardSlots("core", 1));
Board.add(new CardSlots("defence", 3));
}

public static void attackPhase(Player current, Player one, Player two) {
Scanner input = new Scanner(System.in);
current = one;
Player other = opposite(current, one, two);
String from, to;
int f, t;
System.out.println("From which position do you want to attack?");
from = input.nextLine();
System.out.println("Which slot?");
f = input.nextInt();
System.out.println("Which position do you want to attack?");
to = input.nextLine();
System.out.println("Which slot?");
t = input.nextInt();
//attack phase
current.attackOther(other, from, f, to, t);
switchPlayer(current, one, two);
}


public void attackOther(Player c, String from, int pos, String to, int opos){
if(from.equals("uber")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.u.getAtk(pos));
    }
}
if(from.equals("atk")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.a.getAtk(pos));
    }
}
if(from.equals("coreDef")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.cd.getAtk(pos));
    }
}
if(from.equals("core")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.c.getAtk(pos));
    }
}
if(from.equals("def")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.d.getAtk(pos));
    }
}
}
json
"cardCheck": "/src/Game/cardDatabase.java/cardData",

public Uber u = new Uber();
public Attack a = new Attack();
public CoreDef cd = new CoreDef();
public Core c = new Core();
public Defense d = new Defense();

public ArrayList<Card> u = new ArrayList<>();
public ArrayList<Card> a = new ArrayList<>();
public ArrayList<Card> cd = new ArrayList<>();
public ArrayList<Card> c = new ArrayList<>();
public ArrayList<Card> d = new ArrayList<>();

package Game;

public interface CardInsides {
int getUberAtk();

int getUberDef();

int getAtkAtk();

int getAtkDef();

int getCDefAtk();

int getCDefDef();

int getCoreAtk();

int getCoreDef();

int getDefAtk();

int getDefDef();

//board calls
int[] getUber();

int[] getAtk();

int[] getCDef();

int[] getCore();

int[] getDef();

String activeTypeOne();

String activeTypeTwo();

//void specialAttack();

if (act.equals("1")) {

}
if (act.equals("2")) {
//current.getHand();
}
if (act.equals("3")) {

}
if (act.equals("4")) {

}
if (act.equals("5")) {


}

if (pos.equals("uber")) {

}
if (pos.equals("atk")) {

}
if (pos.equals("coreDef")) {

}
if (pos.equals("core")) {

}
if (pos.equals("def")) {

}

public interface Position{
LinkedList<Card> getSlots();
boolean hasOpenSlots();
int[] getStats(Card input);
int getOS();
}
public LinkedList<Card> uberSlots(){

    return u.slots;
}
public LinkedList<Card> atkSlots(){

    return a.slots;
}
public LinkedList<Card> cDefSlots(){


    return cd.slots;
}
public LinkedList<Card> cSlots(){

    return c.slots;
}
public LinkedList<Card> defSlots(){

    return d.slots;
}

public void addToSlots(int posIndex, Card fromHand){
slots.add(posIndex, fromHand);
}
public void removeFromSlots(int posIndex){
slots.remove(posIndex);
}
public boolean hasOpenSlots(){
return slots.size() != openSlots;
}
public int getOS(){
if(slots.size() != openSlots) {
return slots.size();
}else {
return openSlots;
}
}

private final Uber u = new Uber();
private final Attack a = new Attack();
private final CoreDef cd = new CoreDef();
private final Core c = new Core();
private final Defense d = new Defense();


public void addToSpace(String posName, Card here){


switch(posName){
case "uber" ->{
if(!u.hasOpenSlots()){
    System.err.println("All uber space are full");
}
u.slots.add(here);
}
case "atk" -> {
if(!a.hasOpenSlots()){
    System.err.println("All attack spaces are full");
}
a.getSlots().add(here);

}
case "coreDef" ->{
if(!cd.hasOpenSlots()){
    System.err.println("All core def spaces are full");
}
cd.getSlots().add(here);

}
case "core" ->{
if(!c.hasOpenSlots()){
    System.err.println("All core spaces are full");
}
c.getSlots().add(here);

}
case "def" ->{
if(!d.hasOpenSlots()){
    System.err.println("All defence spaces are full");
}
d.getSlots().add(here);

}
}

}

public void makeNullSpace(String posName, int num){
switch(posName){
case "uber" ->{
if(!u.hasOpenSlots()){
    System.err.println("Uber is Empty");
}
u.slots.remove(num);
//u.slots.add(num, cc.pack.get(0)); cc = cardDatabase jic
}
case "atk" ->{
if(!a.hasOpenSlots()){
    System.err.println("Attack is Empty");
}
a.slots.remove(num);
//a.slots.add(num, cc.pack.get(0));
}
case "coreDef" ->{
if(!cd.hasOpenSlots()){
    System.err.println("CoreDef is Empty");
}
cd.slots.remove(num);
//cd.slots.add(num, cc.pack.get(0));
}
case "core" ->{
if(!c.hasOpenSlots()){
    System.err.println("Core is Empty");
}
c.slots.remove(num);
//c.slots.add(num, cc.pack.get(0));

}
case "def" ->{
if(!d.hasOpenSlots()){
    System.err.println("Defence is Empty");
}
d.slots.remove(num);
//d.slots.add(num, cc.pack.get(0));

}
}
}

public int defenceCount(){
//get uber def if the space is null add zero
int ub = 0,at = 0,cod = 0,de = 0;
for(int i = 0; i < u.getOS(); i++){
int tmp = u.getDef(i);
ub = ub + tmp;
}

//get atk def
for(int i = 0; i < a.getOS(); i++){
int tmp = a.getDef(i);
at = at + tmp;
}

// get core-def def
for(int i = 0; i < cd.getOS(); i++){
int tmp = cd.getDef(i);
cod = cod + tmp;
}

//get def1 def bc why not make it even more confusing
for(int i = 0; i < d.getOS(); i++){
int tmp = d.getDef(i);
de = de + tmp;
}

return ub + at + cod + c.getDef() + de;
}
public int attackCount(){
//get uber atk if the space is null add zero
int ub = 0,at = 0,cod = 0,de = 0;
for(int i = 0; i < u.getOS(); i++){
int tmp = u.getAtk(i);
ub = ub + tmp;

}

//get atk atk
for(int i = 0; i < a.getOS(); i++){
int tmp = a.getAtk(i);
at = at + tmp;

}

// get core-def atk
for(int i = 0; i < cd.getOS(); i++){
int tmp = cd.getAtk(i);
cod = cod + tmp;
}

//get def atk
for(int i = 0; i < d.getOS(); i++){
int tmp = d.getAtk(i);
de = de + tmp;
}

return ub + at + cod + c.getAtk() + de;
}

package Game.Slots;
import Game.Card;
import Game.cardDatabase;

import java.util.LinkedList;

public class Uber implements Board.Position {
private final int openSlots = 3;

public LinkedList<Card> slots = new LinkedList<>();
public cardDatabase cd = new cardDatabase();

public int[] getStats(Card in){
return in.getUber();
}

public int getAtk(int n){
if(slots.get(n) == null){
slots.add(n, cd.pack.get(0));
}else {
return slots.get(n).getUberAtk();
}
return 0;
}

public int getDef(int n){
if(slots.get(n) == null){
slots.add(n, cd.pack.get(0));
}else {
return slots.get(n).getUberDef();
}
return 0;
}

public boolean hasOpenSlots(){
return slots.size() != openSlots;
}
public int getOS(){
if(slots.size() != openSlots) {
return slots.size();
}else {
return openSlots;
}
}
@Override
public LinkedList<Card> getSlots() {
return slots;
}

public String toString(){
return slots.toString();
}

//List<Board> board = List.of(new Board(UBER),new Board(ATTACK), new Board(CoreDEFENCE), new Board(CORE),new Board(
DEFENCE));

}

Position p;
for(int i = 0; i < p.getSlots().size(); i++ ) {
if (p.getSlots().get(i) == null) {
p.getSlots().add(cd.pack.get(0));
}
}

// private final int[] uberAtk;
// //private final int[] uberAtkDEF;
// private final int[] attack;
// //private final int[] attackDEF;
// private final int[] coreDef;
// //private final int[] coreDefDEF;
// private final int[] core;
// //private final int[] coreDEF;
// private final int[] defence;
//private final int[] defenceDEF;

//        uberAtk = uAtk;
//        //uberAtkDEF = uADef;
//        attack = atk;
//        //attackDEF = aDef;
//        coreDef = cDef;
//        //coreDefDEF = cDDef;
//        core = corn;
//        //coreDEF = cDef;
//        defence = def;
//defenceDEF = dAtk;


public int getUberAtk() {
return uberAtk[0];
}
public int getUberDef() {
return uberAtk[1];
}
public int getAtkAtk() {
return attack[0];
}
public int getAtkDef() {
return attack[1];
}
public int getCDefAtk() {
return coreDef[0];
}
public int getCDefDef() {
return coreDef[1];
}
public int getCoreAtk() {
return core[0];
}
public int getCoreDef() {
return core[1];
}

public int getDefAtk() {
return defence[0];
}

public int getDefDef() {
return defence[1];
}

//for board calls
public int[] getUber() {
return uberAtk;
}

public int[] getAtk() {
return attack;
}

public int[] getCDef() {
return coreDef;
}

public int[] getCore() {
return core;
}

public int[] getDef() {
return defence;
}

public enum cardType{
PLANT, WATER, FLOWER, TOOL, ANIMAL, FARM, METAL, ORE, ITEM, WOOD, ENHANCED, NEUTRAL;
}

public interface ICommand{
void execute();
}
ICommand onCardPlayedCommand;
ICommand limitedTimeSkillCommand;
public void applyAtkBuff(int buff){
if(onCardPlayedCommand != null){
   onCardPlayedCommand.execute();
}
}
public void applyDefBuff(int buff){

}
public int getModNum(int mod){
return mod;
}
public void atkTypeMod(String typeName){
    Position p = (Position) p.getSlots();
    for (Card inBoard: p.getSlots()) {
        if(p.getSlots().get(inBoard).activeTypeOne().equals(typeName) ){
            pos.card.attackStats  = stats + mod
        }
    }
}

System.out.print(UBER.printSlots_ToBoard());
System.out.print(ATTACK.printSlots_ToBoard());
System.out.print(CoreDEFENCE.printSlots_ToBoard());
System.out.print(CORE.printSlots_ToBoard());
System.out.println(DEFENCE.printSlots_ToBoard());

public enum Modifier{
atkMod(0){
Card test;
void atk(Position pos){
test.getValue(pos)[0] = test.getValue(pos)[0]  + atkMod.mod;
}
}, noSkill(0);
private int mod;
Modifier(int modNum){
modNum = mod;
}

public int adjustMod(int newMod){
mod = newMod;
return mod;
}

}
private Card in;

public Positions(positions type, Card inPlay){
in = inPlay;

}
public boolean hasOpenSlots() {
return slots.size() != openSlots;
}

public void printBoard() {

}
//LinkedList<Card> slots = new LinkedList<>();
//boolean hasOpenSlots();

 public int[] getStats(int cardIndex_onBoard) {
   return slots.get(cardIndex_onBoard).getValue(DEFENCE);
 }

public int getAtk(int cardIndex_onBoard) {
if (slots.get(cardIndex_onBoard) == null) {
       return 0;
   } else {
       return slots.get(cardIndex_onBoard).getValue(DEFENCE)[0];
   }
}

public int getDef(int cardIndex_onBoard) {
   if (slots.get(cardIndex_onBoard) == null) {
       return 0;
   } else {
       return slots.get(cardIndex_onBoard).getValue(DEFENCE)[1];
   }
}
public LinkedList<Card> getSlots() {
return slots;
}
public String printSlots_ToBoard(){ return slots.toString();}

//            case "ATTACK" -> {Positions a = new Positions(ATTACK,fromHand);}
//            case "CoreDEFENCE" -> {Positions cd = new Positions(CoreDEFENCE, fromHand);}
//            case "CORE" -> CORE.getSlots().add(fromHand);
//            case "DEFENCE" -> DEFENCE.getSlots().add(fromHand);

//            case "UBER" -> UBER.getSlots().remove(posIndex);
//            case "ATTACK" -> ATTACK.getSlots().remove(posIndex);
//            case "CoreDEFENCE" -> CoreDEFENCE.getSlots().remove(posIndex);
//            case "CORE" -> CORE.getSlots().remove(posIndex);
//            case "DEFENCE" -> DEFENCE.getSlots().remove(posIndex);

Calculation
//        String jString = "{_comment:type_based_cards,name:Blank,cardID:-1,typeCheck:NEUTRAL,modValueAtk:0,modValueDef:0}";
//        JSONObject jsonMODObject = new JSONObject(jString);
//        String t = jsonMODObject.getString("name");
//        int id = jsonMODObject.getInt("cardID");
//        System.out.println(t + id);

public static Player opposite(Player loser, Player one, Player two) { //for winner thing
  if (loser == one) {
    System.out.println("Winner Player two");
    return two;

  } else if(loser == two){
      System.out.println("Winner Player one");
      return one;
  }
  return loser;
}
from board position enum
public int getOSNum(){ return os; }
    //if openSlotsNum = number of cards in slots return false else true
    //public boolean hasOpenSlots() { return slot.size() != 0; } //onTable.getOSNum()
    public enum Card_Type{
        PLANT, WATER, TOOL, FLOWER, FARM, ANIMAL, METAL, ORE, ITEMS, WOOD, LUCKY, NEUTRAL;
    }
public String activeTypes(){ return cardTypeONE + cardTypeTWO;}
    public interface boardPosition_Action {
        Board_Positions currentPlace();
        int[] getStats();
        int getAtk();
        int getDef();
        Card getSlot();
        void remove();
        boolean isEmpty();
    }
//b.printBoard();
//System.out.println("Uber:" + UBER.getSlots().toString() + ", Attack:" + ATTACK.getSlots().toString() + ", Core-Def:" + CoreDEFENCE.getSlots().toString() + ", Core:" + CORE.getSlots().toString() + ", Defence:" + DEFENCE.getSlots().toString());

package Game;

import java.util.ArrayList;

public class Pot {
    private int numItemsInPot = 0;
    private double multiplier = 1;
    private final ArrayList<Card> pot = new ArrayList<>();

    public void get(Player current, int cardIndex) {
        pot.add(current.getHand().get(cardIndex));
        numItemsInPot++;
        multiplier = Math.abs(multiplier + 0.5);
        current.getHand().remove(cardIndex);
    }

    public void getHandAmt(Player current,int cardIndex) {
        for (int k = 0; k < current.getHand().size(); k++) {
            if (current.getHand().get(k) == current.getHand().get(cardIndex)) {
                pot.add(current.getHand().get(cardIndex));
                current.getHand().remove(cardIndex);
                numItemsInPot++;
                multiplier = Math.abs(multiplier + 0.5);
            }
        }
    }

    public void getAll(Player current, int cardIndex) {
        for (int i = 0; i < current.getDeck().size() - 1; i++) {
            if (current.getDeck().get(i) == current.getHand().get(cardIndex)) {
                pot.add(current.getDeck().get(cardIndex));
                current.getDeck().remove(cardIndex);
                numItemsInPot++;
                multiplier = Math.abs(multiplier + 0.5);
            }
        }
        for (int k = 0; k < current.getHand().size(); k++) {
            if (current.getHand().get(k) == current.getHand().get(cardIndex)) {
                pot.add(current.getHand().get(cardIndex));
                current.getHand().remove(cardIndex);
                numItemsInPot++;
                multiplier = Math.abs(multiplier + 0.5);
            }
        }
    }

    public void seePot(){
        System.out.println(pot);
    }

    public long problems() {
        return Math.abs(Math.round(numItemsInPot * multiplier));
    }
}

public void gamble(Player current, int whichCard, String options) {
    switch(options){
      case "one" -> p.get(current, whichCard);
      case "two" -> p.getHandAmt(current, whichCard);
      case "all" -> p.getAll(current, whichCard);
    }
}
public Pot getPot(){
        p.seePot();
        return p;
}
case "4" ->{
  System.out.println("which card in your hand? (number left to right)");
  System.out.println(numSelectInput);
  System.out.println("how many? one) 1 two) everything in hand all) every version in deck and hand");
  String test = input.nextLine();
  current.gamble(current, numSelectInput, test);
}

"description":
  {
    "identifier": "format:Plain_Tree"
  },

Map<Integer, List<String>> cardIDPositionMap;
Map<String, List<String>> typeToPositionMap;
List<String> positions;
for(int j = 0; j < cookBook.length(); j++ ) {
    JSONObject tmpRecipe = cookBook.getJSONObject(j);
    JSONArray recipeIngredients = tmpRecipe.getJSONArray("ingredients");
    for(int k = 0; k < recipeIngredients.length(); k++){
        JSONObject tmpIngredients = recipeIngredients.getJSONObject(k);
        boolean needCard = tmpIngredients.getBoolean("cardCheck");
        boolean needType = tmpIngredients.getBoolean("typeCheck");
        JSONArray getPos = tmpIngredients.getJSONArray("position");

        if(!needCard && needType) {
          String tmpType = tmpIngredients.getString("type");

          for (int l = 0; l < getPos.length(); l++) {
              JSONObject tmpPos = getPos.getJSONObject(l);
          }
       }
   }
}
 "skills": [
    {
      "_comment": "type_based_cards",

      "card": {"name": "Blank", "cardID": -1, "skillType": "type", "typeCheck": "NEUTRAL", "modValueAtk": 0, "modValueDef": 0}
    },
    {
      "_comment": "type-position_based_cards",

      "card": {"name": "Apple", "cardID": 6, "skillType": "type-position", "typeCheck": "PLANT", "posCheck": "CORE", "modValueAtk": 0, "modValueDef": 1}
    },
    {
      "card": {"name": "Cornflower", "cardID": 10, "skillType": "type-position", "typeCheck": "FLOWER", "posCheck": "CORE", "modValueAtk": 1, "modValueDef": 0}
    },
    {
      "card": {
        "name": "Mutton",
        "cardID": 7,
        "skillType": "type-position",
        "typeCheck": "ANIMAL",
        "posCheck": "CORE",
        "modValueAtk": 2,
        "modValueDef": 0
      }
    },
    {
      "_comment": "card_based_cards",

      "name": "HayBale",
      "cardID": 8,
      "skillType": "card",
      "cardIDCheck": 31,
      "modValueAtk": 1,
      "modValueDef": 1
    }
  ]

}
Calculation p1 = new Calculation(one, two);
Calculation p2 = new Calculation( two, one);

            if(p1.calculate()){
                System.out.println("Player 1 Wins");
                isWinner = p1.calculate();
            }else if(p2.calculate()){
                System.out.println("Player 2 Wins");
                isWinner = p2.calculate();
            }
int tally = 0;
        for(int i = 0; i < 4; i++){
            for(int j = 0; j < 3; j++){
                if(board_Grid[i][j].isEmpty()){
                    tally++;
                }
            }
        }
package Game.Slots;

import java.io.FileReader;
import java.io.IOException;

import Game.*;
import org.json.JSONArray;
import org.json.JSONObject;

import Game.Player;
import static Game.Slots.Board.Board_Positions.*;

public class Calculation {

    //numbers for final use
    private int uTotalATK, aTotalATK, cdTotalATK, dTotalATK; // only need one set bc it'll switch outside then start this again
    private int uTotalDEF, aTotalDEF, cdTotalDEF, dTotalDEF;

    public Calculation(Player first, Player second) throws IOException {
        Board one = first.getBoard();
        Board two = second.getBoard();

        //get the core stats for later
        int coreATKMod1, coreDEFMod2;
        if(one.getGrid()[2][1] == null){
            coreATKMod1 = 0;
        }else { coreATKMod1 = one.getGrid()[2][1].getAtk(); }

        if(two.getGrid()[2][1] == null) {
            coreDEFMod2 = 0;
        } else{ coreDEFMod2 = two.getGrid()[2][1].getDef(); }

        int overflow;

        //fileReader to get the file then a while loop to build a string from it
        try(FileReader modReader = new FileReader("C:\\Users\\sensa\\IdeaProjects\\testGame\\src\\Game\\CardData\\Modifier.json")) {
            StringBuilder modString = new StringBuilder(" ");
            int i;
            while ((i = modReader.read()) != -1) {
                //System.out.print((char)i);
                modString.append((char) i);
            }
            JSONObject jsonMODObject = new JSONObject(modString.toString());
            JSONArray skillList = (JSONArray) jsonMODObject.get("skills");

            //go through skillList, if the id matches card on board get mod numbers according to things (card type, whatever)
            boolean done = false;
            Board current, other;
            current = one;
            other = two;
            int l = 0;
            while (!done) {
                for (int j = 0; j < skillList.length(); j++) {
                    JSONObject tmp = skillList.getJSONObject(j);
                    int tmpI = tmp.getInt("cardID");
                    for (int k = 0; k < current.getGrid().length; k++) {
                        if(current.isBoardEmpty()) {
                            if (tmpI == current.getGrid()[j][k].getSlot().getId() && !current.getGrid()[j][k].getSlot().isItem()) {
                                //check the skill type
                                checkSkillsATK(tmp, tmp.getString("skillType"), current); // attacker then defence
                            }
                        }
                    }
                    for (int k = 0; k < other.getGrid().length; k++) {
                        if(other.isBoardEmpty()) {
                            if (tmpI == other.getGrid()[j][k].getSlot().getId() && !other.getGrid()[j][k].getSlot().isItem()) {
                                //check the skill type
                                checkSkillsDEF(tmp, tmp.getString("skillType"), other);
                            }
                        }
                    }

                }
                current = switchBoard(current, one, two);
                if (current == one) {
                    other = two;
                } else if (current == two) {
                    other = one;
                }

                if (current == two && l > 0) {
                    done = true;
                }
                l++;
            }
        } catch (IOException ex){
            throw new IOException("Something Has Failed");

        } finally {
            System.out.println("Everything went perfectly... be very afraid");
        }
        //overflow calculations + core additions
        overflow = uTotalDEF - uTotalATK; // uber gets no overflow
        if(overflow > 0){
            uTotalATK = uTotalATK + overflow + coreATKMod1;
        }else{ uTotalATK = uTotalATK + coreATKMod1;}

        overflow = aTotalDEF - aTotalATK;
        if(overflow > 0){
            cdTotalATK = cdTotalATK + overflow + coreATKMod1;
        }else { cdTotalATK = cdTotalATK + coreATKMod1;}

        overflow = cdTotalDEF - cdTotalATK;
        if(overflow > 0){
            dTotalATK = dTotalATK + overflow + coreATKMod1;
        }else{dTotalATK = dTotalATK + coreATKMod1;}

        //defence core additions
        uTotalDEF = uTotalDEF + coreDEFMod2;
        aTotalDEF = aTotalDEF + coreDEFMod2;
        cdTotalDEF = cdTotalDEF + coreDEFMod2;
        dTotalDEF = dTotalDEF + coreDEFMod2;
    }

    public boolean calculate(){ //if true game ends if false game continues
        return uTotalATK > uTotalDEF && aTotalATK > aTotalDEF && cdTotalATK > cdTotalDEF && dTotalATK > dTotalDEF;
    }
//move everything here then trash the rest
    private Board switchBoard(Board current, Board one, Board two) {
        if (current == one) {
            current = two;
            System.out.println("Player two");
            return current;
        }
        if (current == two) {
            current = one;
            System.out.println("Player one");
            return current;

        }
        return current;
    }
    private void checkSkillsATK(JSONObject o,String skillTypeBase, Board attacker){
        switch(skillTypeBase){
            case "type" -> {
                String typeC = o.getString("typeCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(attacker.getGrid()[n][i].isEmpty()) {
                            if (attacker.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[0][i].currentPlace() == UBER || attacker.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueAtk");
                                uTotalATK = uTotalATK + tno;
                            }
                            if (attacker.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[1][i].currentPlace() == ATTACK || attacker.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueAtk");
                                aTotalATK = aTotalATK + tno;
                            }
                            if (attacker.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE || attacker.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                cdTotalATK = cdTotalATK + tno;
                            }
                            if (attacker.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE || attacker.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                dTotalATK = dTotalATK + tno;
                            }
                        }
                    }
                }
            } //get the typeCheck then go through current board. for each card w/ type add mod, return total
            case "type-position" -> {
                String typeC = o.getString("typeCheck");
                String posC = o.getString("posCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(attacker.getGrid()[n][i].isEmpty()) {
                            if (attacker.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[0][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[0][i].currentPlace() == UBER || attacker.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[0][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueAtk");
                                uTotalATK = uTotalATK + tno;
                            }
                            if (attacker.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[1][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[1][i].currentPlace() == ATTACK || attacker.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[1][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueAtk");
                                aTotalATK = aTotalATK + tno;
                            }
                            if (attacker.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[n][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE || attacker.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[n][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                cdTotalATK = cdTotalATK + tno;
                            }
                            if (attacker.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[3][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE || attacker.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[3][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                dTotalATK = dTotalATK + tno;
                            }
                        }
                    }
                }
            } //get typeCheck and posCheck, go through current board, return total
            case "card" -> {
                int cID = o.getInt("cardID");
                for(int i = 0; i < 4; i++){
                    for(int j = 0; j < 3; j++){
                        if(attacker.getGrid()[i][j].isEmpty()) {
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == UBER) {
                                int tno = o.getInt("modValueAtk");
                                uTotalATK = uTotalATK + tno;
                            }
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueAtk");
                                aTotalATK = aTotalATK + tno;
                            }
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                cdTotalATK = cdTotalATK + tno;
                            }
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                dTotalATK = dTotalATK + tno;
                            }
                        }
                    }
                }
            }//get cardIDCheck, if card there add mod
        }
    }
    private void checkSkillsDEF(JSONObject o,String skillTypeBase, Board defender){
        switch(skillTypeBase){
            case "type" -> {
                String typeC = o.getString("typeCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(defender.getGrid()[n][i].isEmpty()) {
                            if (defender.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[0][i].currentPlace() == UBER || defender.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueDef");
                                uTotalDEF = uTotalDEF + tno;
                            }
                            if (defender.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[1][i].currentPlace() == ATTACK || defender.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueDef");
                                aTotalDEF = aTotalDEF + tno;
                            }
                            if (defender.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE || defender.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueDef");
                                cdTotalDEF = cdTotalDEF + tno;
                            }
                            if (defender.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[3][i].currentPlace() == DEFENCE || defender.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueDef");
                                dTotalDEF = dTotalDEF + tno;
                            }
                        }
                    }
                }
            } //get the typeCheck then go through current board. for each card w/ type add mod, return total
            case "type-position" -> {
                String typeC = o.getString("typeCheck");
                String posC = o.getString("posCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(defender.getGrid()[n][i].isEmpty()) {
                            if (defender.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[0][i].currentPlace()).contentEquals(posC) && defender.getGrid()[0][i].currentPlace() == UBER || defender.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[0][i].currentPlace()).contentEquals(posC) && defender.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueDef");
                                uTotalDEF = uTotalDEF + tno;
                            }
                            if (defender.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[1][i].currentPlace()).contentEquals(posC) && defender.getGrid()[1][i].currentPlace() == ATTACK || defender.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[1][i].currentPlace()).contentEquals(posC) && defender.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueDef");
                                aTotalDEF = aTotalDEF + tno;
                            }
                            if (defender.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[n][i].currentPlace()).contentEquals(posC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE || defender.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[n][i].currentPlace()).contentEquals(posC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueDef");
                                cdTotalDEF = cdTotalDEF + tno;
                            }
                            if (defender.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[3][i].currentPlace()).contentEquals(posC) && defender.getGrid()[3][i].currentPlace() == DEFENCE || defender.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[3][i].currentPlace()).contentEquals(posC) && defender.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueDef");
                                dTotalDEF = dTotalDEF + tno;
                            }
                        }
                    }
                }
            } //get typeCheck and posCheck, go through current board, return total
            case "card" -> {
                int cID = o.getInt("cardID");
                for(int i = 0; i < 4; i++){
                    for(int j = 0; j < 3; j++){
                        if(defender.getGrid()[i][j].isEmpty()) {
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == UBER) {
                                int tno = o.getInt("modValueDef");
                                uTotalDEF = uTotalDEF + tno;
                            }
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueDef");
                                aTotalDEF = aTotalDEF + tno;
                            }
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueDef");
                                cdTotalDEF = cdTotalDEF + tno;
                            }
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueDef");
                                dTotalDEF = dTotalDEF + tno;
                            }
                        }
                    }
                }
            }//get cardIDCheck, if card there add mod
        }
    }

    public static void main(String[] args) throws IOException {
        Player b = new Human();
        Player bb = new Human();

        Calculation c = new Calculation(b, bb);
        c.calculate();
    }
}

uberRow[0] = board_Grid[0][0].getAtk() + board_Grid[0][1].getAtk() + board_Grid[0][2].getAtk();
uberRow[1] = board_Grid[0][0].getDef() + board_Grid[0][1].getDef() + board_Grid[0][2].getDef();
        enemy.getUberRow()[0] = enemy.getGrid()[0][0].getAtk() + enemy.getGrid()[0][1].getAtk() + enemy.getGrid()[0][2].getAtk();
        enemy.getUberRow()[1] = enemy.getGrid()[0][0].getDef() + enemy.getGrid()[0][1].getDef() + enemy.getGrid()[0][2].getDef();
        atkRow[0] = board_Grid[1][0].getAtk() + board_Grid[1][2].getAtk();
        atkRow[1] = board_Grid[1][0].getDef() + board_Grid[1][2].getDef();
        enemy.getAtkRow()[0] = enemy.getGrid()[1][0].getAtk() + enemy.getGrid()[1][2].getAtk();
        enemy.getAtkRow()[1] = enemy.getGrid()[1][0].getDef() + enemy.getGrid()[1][2].getDef();
        cDefRow[0] = board_Grid[1][1].getAtk() + board_Grid[2][0].getAtk() + board_Grid[2][2].getAtk();
        cDefRow[1] = board_Grid[1][1].getDef() + board_Grid[2][0].getDef() + board_Grid[2][2].getDef();
        enemy.getCDefRow()[0] = enemy.getGrid()[1][1].getAtk() + enemy.getGrid()[2][0].getAtk() + enemy.getGrid()[2][2].getAtk();
        enemy.getCDefRow()[1] = enemy.getGrid()[1][1].getDef() + enemy.getGrid()[2][0].getDef() + enemy.getGrid()[2][2].getDef();
        coreBlock[0] = board_Grid[2][1].getAtk();
        coreBlock[1] = board_Grid[2][1].getDef();
        enemy.getCoreBlock()[0] = enemy.getGrid()[2][1].getAtk();
        enemy.getCoreBlock()[1] = enemy.getGrid()[2][1].getDef();
        defRow[0] = board_Grid[3][0].getAtk() + board_Grid[3][1].getAtk() + board_Grid[3][2].getAtk();
        defRow[1] = board_Grid[3][0].getDef() + board_Grid[3][1].getDef() + board_Grid[3][2].getDef();
        enemy.getDefRow()[0] = enemy.getGrid()[3][0].getAtk() + enemy.getGrid()[3][1].getAtk() + enemy.getGrid()[3][2].getAtk();
        enemy.getDefRow()[1] = enemy.getGrid()[3][0].getDef() + enemy.getGrid()[3][1].getDef() + enemy.getGrid()[3][2].getDef();

uberRow = new int[2];
atkRow = new int[2];
cDefRow = new int[2];
coreBlock = new int[2];
defRow = new int[2];