CardInside Interface stuff
public int[] getUber(){
int[] u = new int[]{uberAtkATK,uberAtkDEF};
return u;
}
public int[] getAtk(){
int[] a = new int[]{attackATK, attackDEF};
return a;
}
public int[] getCDef(){
int[] cd = new int[]{coreDefATK, coreDefATK};
return cd;
}
public int[] getCore(){
int[] c = new int[]{coreATK, coreDEF};
return c;
}
public int[] getDef(){
int[] d = new int[]{defenceATK,defenceDEF};
return d;
}
public int[] getUber();
public int[] getAtk();
public int[] getCDef();
public int[] getCore();
public int[] getDef();

public int activeStats(Board pos);
public String activeType();

public void coreSkill(){
}
public void skill(){
}

Board
public class Board {

//play method stuff
// while(attackPhase){
// System.exit(130);
// }

package Game;

import java.util.ArrayList;

public class CardSlots {
private final String name;
private final int openSlots;
public ArrayList<Card> slot = new ArrayList<>();

public CardSlots(String Name, int oSlots) {
name = Name;
openSlots = oSlots;
}

public int[] getStats(int slotNum) {
int[] test = new int[]{0, 1};
if (name.equals("uber")) {
return slot.get(slotNum).getUber();
}
if (name.equals("attack")) {
return slot.get(slotNum).getAtk();

}
if (name.equals("core defence")) {
return slot.get(slotNum).getCDef();

}
if (name.equals("core")) {
return slot.get(slotNum).getCore();

}
if (name.equals("defence")) {
return slot.get(slotNum).getDef();

}

return test;
}

public int getOpenSlots() {
return openSlots;
}

public String toString() {
return slot.toString();
}

}
package Game.Slots;
import Game.Card;

public interface CardSlots {
int[] getStats(Card in);
int getAtk(int n);
int getDef(int n);
int showOpenSlots();
}

public void makeBoard() {
Board.add(new CardSlots("uber", 3));
Board.add(new CardSlots("attack", 2));
Board.add(new CardSlots("core defence", 3));
Board.add(new CardSlots("core", 1));
Board.add(new CardSlots("defence", 3));
}

public static void attackPhase(Player current, Player one, Player two) {
Scanner input = new Scanner(System.in);
current = one;
Player other = opposite(current, one, two);
String from, to;
int f, t;
System.out.println("From which position do you want to attack?");
from = input.nextLine();
System.out.println("Which slot?");
f = input.nextInt();
System.out.println("Which position do you want to attack?");
to = input.nextLine();
System.out.println("Which slot?");
t = input.nextInt();
//attack phase
current.attackOther(other, from, f, to, t);
switchPlayer(current, one, two);
}


public void attackOther(Player c, String from, int pos, String to, int opos){
if(from.equals("uber")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.u.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.u.getAtk(pos));
    }
}
if(from.equals("atk")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.a.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.a.getAtk(pos));
    }
}
if(from.equals("coreDef")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.cd.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.cd.getAtk(pos));
    }
}
if(from.equals("core")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.c.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.c.getAtk(pos));
    }
}
if(from.equals("def")){

    if(to.equals("uber")){
        Math.abs(c.playBoard().u.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("atk")){
        Math.abs(c.playBoard().a.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("coreDef")){
        Math.abs(c.playBoard().cd.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("core")){
        Math.abs(c.playBoard().c.getDef(opos) - b.d.getAtk(pos));
    }
    if(to.equals("def")){
        Math.abs(c.playBoard().d.getDef(opos) - b.d.getAtk(pos));
    }
}
}
json
"cardCheck": "/src/Game/cardDatabase.java/cardData",

public Uber u = new Uber();
public Attack a = new Attack();
public CoreDef cd = new CoreDef();
public Core c = new Core();
public Defense d = new Defense();

public ArrayList<Card> u = new ArrayList<>();
public ArrayList<Card> a = new ArrayList<>();
public ArrayList<Card> cd = new ArrayList<>();
public ArrayList<Card> c = new ArrayList<>();
public ArrayList<Card> d = new ArrayList<>();

package Game;

public interface CardInsides {
int getUberAtk();

int getUberDef();

int getAtkAtk();

int getAtkDef();

int getCDefAtk();

int getCDefDef();

int getCoreAtk();

int getCoreDef();

int getDefAtk();

int getDefDef();

//board calls
int[] getUber();

int[] getAtk();

int[] getCDef();

int[] getCore();

int[] getDef();

String activeTypeOne();

String activeTypeTwo();

//void specialAttack();

if (act.equals("1")) {

}
if (act.equals("2")) {
//current.getHand();
}
if (act.equals("3")) {

}
if (act.equals("4")) {

}
if (act.equals("5")) {


}

if (pos.equals("uber")) {

}
if (pos.equals("atk")) {

}
if (pos.equals("coreDef")) {

}
if (pos.equals("core")) {

}
if (pos.equals("def")) {

}

public interface Position{
LinkedList<Card> getSlots();
boolean hasOpenSlots();
int[] getStats(Card input);
int getOS();
}
public LinkedList<Card> uberSlots(){

    return u.slots;
}
public LinkedList<Card> atkSlots(){

    return a.slots;
}
public LinkedList<Card> cDefSlots(){


    return cd.slots;
}
public LinkedList<Card> cSlots(){

    return c.slots;
}
public LinkedList<Card> defSlots(){

    return d.slots;
}

public void addToSlots(int posIndex, Card fromHand){
slots.add(posIndex, fromHand);
}
public void removeFromSlots(int posIndex){
slots.remove(posIndex);
}
public boolean hasOpenSlots(){
return slots.size() != openSlots;
}
public int getOS(){
if(slots.size() != openSlots) {
return slots.size();
}else {
return openSlots;
}
}

private final Uber u = new Uber();
private final Attack a = new Attack();
private final CoreDef cd = new CoreDef();
private final Core c = new Core();
private final Defense d = new Defense();


public void addToSpace(String posName, Card here){


switch(posName){
case "uber" ->{
if(!u.hasOpenSlots()){
    System.err.println("All uber space are full");
}
u.slots.add(here);
}
case "atk" -> {
if(!a.hasOpenSlots()){
    System.err.println("All attack spaces are full");
}
a.getSlots().add(here);

}
case "coreDef" ->{
if(!cd.hasOpenSlots()){
    System.err.println("All core def spaces are full");
}
cd.getSlots().add(here);

}
case "core" ->{
if(!c.hasOpenSlots()){
    System.err.println("All core spaces are full");
}
c.getSlots().add(here);

}
case "def" ->{
if(!d.hasOpenSlots()){
    System.err.println("All defence spaces are full");
}
d.getSlots().add(here);

}
}

}

public void makeNullSpace(String posName, int num){
switch(posName){
case "uber" ->{
if(!u.hasOpenSlots()){
    System.err.println("Uber is Empty");
}
u.slots.remove(num);
//u.slots.add(num, cc.pack.get(0)); cc = cardDatabase jic
}
case "atk" ->{
if(!a.hasOpenSlots()){
    System.err.println("Attack is Empty");
}
a.slots.remove(num);
//a.slots.add(num, cc.pack.get(0));
}
case "coreDef" ->{
if(!cd.hasOpenSlots()){
    System.err.println("CoreDef is Empty");
}
cd.slots.remove(num);
//cd.slots.add(num, cc.pack.get(0));
}
case "core" ->{
if(!c.hasOpenSlots()){
    System.err.println("Core is Empty");
}
c.slots.remove(num);
//c.slots.add(num, cc.pack.get(0));

}
case "def" ->{
if(!d.hasOpenSlots()){
    System.err.println("Defence is Empty");
}
d.slots.remove(num);
//d.slots.add(num, cc.pack.get(0));

}
}
}

public int defenceCount(){
//get uber def if the space is null add zero
int ub = 0,at = 0,cod = 0,de = 0;
for(int i = 0; i < u.getOS(); i++){
int tmp = u.getDef(i);
ub = ub + tmp;
}

//get atk def
for(int i = 0; i < a.getOS(); i++){
int tmp = a.getDef(i);
at = at + tmp;
}

// get core-def def
for(int i = 0; i < cd.getOS(); i++){
int tmp = cd.getDef(i);
cod = cod + tmp;
}

//get def1 def bc why not make it even more confusing
for(int i = 0; i < d.getOS(); i++){
int tmp = d.getDef(i);
de = de + tmp;
}

return ub + at + cod + c.getDef() + de;
}
public int attackCount(){
//get uber atk if the space is null add zero
int ub = 0,at = 0,cod = 0,de = 0;
for(int i = 0; i < u.getOS(); i++){
int tmp = u.getAtk(i);
ub = ub + tmp;

}

//get atk atk
for(int i = 0; i < a.getOS(); i++){
int tmp = a.getAtk(i);
at = at + tmp;

}

// get core-def atk
for(int i = 0; i < cd.getOS(); i++){
int tmp = cd.getAtk(i);
cod = cod + tmp;
}

//get def atk
for(int i = 0; i < d.getOS(); i++){
int tmp = d.getAtk(i);
de = de + tmp;
}

return ub + at + cod + c.getAtk() + de;
}

package Game.Slots;
import Game.Card;
import Game.cardDatabase;

import java.util.LinkedList;

public class Uber implements Board.Position {
private final int openSlots = 3;

public LinkedList<Card> slots = new LinkedList<>();
public cardDatabase cd = new cardDatabase();

public int[] getStats(Card in){
return in.getUber();
}

public int getAtk(int n){
if(slots.get(n) == null){
slots.add(n, cd.pack.get(0));
}else {
return slots.get(n).getUberAtk();
}
return 0;
}

public int getDef(int n){
if(slots.get(n) == null){
slots.add(n, cd.pack.get(0));
}else {
return slots.get(n).getUberDef();
}
return 0;
}

public boolean hasOpenSlots(){
return slots.size() != openSlots;
}
public int getOS(){
if(slots.size() != openSlots) {
return slots.size();
}else {
return openSlots;
}
}
@Override
public LinkedList<Card> getSlots() {
return slots;
}

public String toString(){
return slots.toString();
}

//List<Board> board = List.of(new Board(UBER),new Board(ATTACK), new Board(CoreDEFENCE), new Board(CORE),new Board(
DEFENCE));

}

Position p;
for(int i = 0; i < p.getSlots().size(); i++ ) {
if (p.getSlots().get(i) == null) {
p.getSlots().add(cd.pack.get(0));
}
}

// private final int[] uberAtk;
// //private final int[] uberAtkDEF;
// private final int[] attack;
// //private final int[] attackDEF;
// private final int[] coreDef;
// //private final int[] coreDefDEF;
// private final int[] core;
// //private final int[] coreDEF;
// private final int[] defence;
//private final int[] defenceDEF;

//        uberAtk = uAtk;
//        //uberAtkDEF = uADef;
//        attack = atk;
//        //attackDEF = aDef;
//        coreDef = cDef;
//        //coreDefDEF = cDDef;
//        core = corn;
//        //coreDEF = cDef;
//        defence = def;
//defenceDEF = dAtk;


public int getUberAtk() {
return uberAtk[0];
}
public int getUberDef() {
return uberAtk[1];
}
public int getAtkAtk() {
return attack[0];
}
public int getAtkDef() {
return attack[1];
}
public int getCDefAtk() {
return coreDef[0];
}
public int getCDefDef() {
return coreDef[1];
}
public int getCoreAtk() {
return core[0];
}
public int getCoreDef() {
return core[1];
}

public int getDefAtk() {
return defence[0];
}

public int getDefDef() {
return defence[1];
}

//for board calls
public int[] getUber() {
return uberAtk;
}

public int[] getAtk() {
return attack;
}

public int[] getCDef() {
return coreDef;
}

public int[] getCore() {
return core;
}

public int[] getDef() {
return defence;
}

public enum cardType{
PLANT, WATER, FLOWER, TOOL, ANIMAL, FARM, METAL, ORE, ITEM, WOOD, ENHANCED, NEUTRAL;
}

public interface ICommand{
void execute();
}
ICommand onCardPlayedCommand;
ICommand limitedTimeSkillCommand;
public void applyAtkBuff(int buff){
if(onCardPlayedCommand != null){
   onCardPlayedCommand.execute();
}
}
public void applyDefBuff(int buff){

}
public int getModNum(int mod){
return mod;
}
public void atkTypeMod(String typeName){
    Position p = (Position) p.getSlots();
    for (Card inBoard: p.getSlots()) {
        if(p.getSlots().get(inBoard).activeTypeOne().equals(typeName) ){
            pos.card.attackStats  = stats + mod
        }
    }
}

System.out.print(UBER.printSlots_ToBoard());
System.out.print(ATTACK.printSlots_ToBoard());
System.out.print(CoreDEFENCE.printSlots_ToBoard());
System.out.print(CORE.printSlots_ToBoard());
System.out.println(DEFENCE.printSlots_ToBoard());

public enum Modifier{
atkMod(0){
Card test;
void atk(Position pos){
test.getValue(pos)[0] = test.getValue(pos)[0]  + atkMod.mod;
}
}, noSkill(0);
private int mod;
Modifier(int modNum){
modNum = mod;
}

public int adjustMod(int newMod){
mod = newMod;
return mod;
}

}
private Card in;

public Positions(positions type, Card inPlay){
in = inPlay;

}
public boolean hasOpenSlots() {
return slots.size() != openSlots;
}

public void printBoard() {

}
//LinkedList<Card> slots = new LinkedList<>();
//boolean hasOpenSlots();

 public int[] getStats(int cardIndex_onBoard) {
   return slots.get(cardIndex_onBoard).getValue(DEFENCE);
 }

public int getAtk(int cardIndex_onBoard) {
if (slots.get(cardIndex_onBoard) == null) {
       return 0;
   } else {
       return slots.get(cardIndex_onBoard).getValue(DEFENCE)[0];
   }
}

public int getDef(int cardIndex_onBoard) {
   if (slots.get(cardIndex_onBoard) == null) {
       return 0;
   } else {
       return slots.get(cardIndex_onBoard).getValue(DEFENCE)[1];
   }
}
public LinkedList<Card> getSlots() {
return slots;
}
public String printSlots_ToBoard(){ return slots.toString();}

//            case "ATTACK" -> {Positions a = new Positions(ATTACK,fromHand);}
//            case "CoreDEFENCE" -> {Positions cd = new Positions(CoreDEFENCE, fromHand);}
//            case "CORE" -> CORE.getSlots().add(fromHand);
//            case "DEFENCE" -> DEFENCE.getSlots().add(fromHand);

//            case "UBER" -> UBER.getSlots().remove(posIndex);
//            case "ATTACK" -> ATTACK.getSlots().remove(posIndex);
//            case "CoreDEFENCE" -> CoreDEFENCE.getSlots().remove(posIndex);
//            case "CORE" -> CORE.getSlots().remove(posIndex);
//            case "DEFENCE" -> DEFENCE.getSlots().remove(posIndex);

Calculation
//        String jString = "{_comment:type_based_cards,name:Blank,cardID:-1,typeCheck:NEUTRAL,modValueAtk:0,modValueDef:0}";
//        JSONObject jsonMODObject = new JSONObject(jString);
//        String t = jsonMODObject.getString("name");
//        int id = jsonMODObject.getInt("cardID");
//        System.out.println(t + id);

public static Player opposite(Player loser, Player one, Player two) { //for winner thing
  if (loser == one) {
    System.out.println("Winner Player two");
    return two;

  } else if(loser == two){
      System.out.println("Winner Player one");
      return one;
  }
  return loser;
}
from board position enum
public int getOSNum(){ return os; }
    //if openSlotsNum = number of cards in slots return false else true
    //public boolean hasOpenSlots() { return slot.size() != 0; } //onTable.getOSNum()
    public enum Card_Type{
        PLANT, WATER, TOOL, FLOWER, FARM, ANIMAL, METAL, ORE, ITEMS, WOOD, LUCKY, NEUTRAL;
    }
public String activeTypes(){ return cardTypeONE + cardTypeTWO;}
    public interface boardPosition_Action {
        Board_Positions currentPlace();
        int[] getStats();
        int getAtk();
        int getDef();
        Card getSlot();
        void remove();
        boolean isEmpty();
    }
//b.printBoard();
//System.out.println("Uber:" + UBER.getSlots().toString() + ", Attack:" + ATTACK.getSlots().toString() + ", Core-Def:" + CoreDEFENCE.getSlots().toString() + ", Core:" + CORE.getSlots().toString() + ", Defence:" + DEFENCE.getSlots().toString());

package Game;

import java.util.ArrayList;

public class Pot {
    private int numItemsInPot = 0;
    private double multiplier = 1;
    private final ArrayList<Card> pot = new ArrayList<>();

    public void get(Player current, int cardIndex) {
        pot.add(current.getHand().get(cardIndex));
        numItemsInPot++;
        multiplier = Math.abs(multiplier + 0.5);
        current.getHand().remove(cardIndex);
    }

    public void getHandAmt(Player current,int cardIndex) {
        for (int k = 0; k < current.getHand().size(); k++) {
            if (current.getHand().get(k) == current.getHand().get(cardIndex)) {
                pot.add(current.getHand().get(cardIndex));
                current.getHand().remove(cardIndex);
                numItemsInPot++;
                multiplier = Math.abs(multiplier + 0.5);
            }
        }
    }

    public void getAll(Player current, int cardIndex) {
        for (int i = 0; i < current.getDeck().size() - 1; i++) {
            if (current.getDeck().get(i) == current.getHand().get(cardIndex)) {
                pot.add(current.getDeck().get(cardIndex));
                current.getDeck().remove(cardIndex);
                numItemsInPot++;
                multiplier = Math.abs(multiplier + 0.5);
            }
        }
        for (int k = 0; k < current.getHand().size(); k++) {
            if (current.getHand().get(k) == current.getHand().get(cardIndex)) {
                pot.add(current.getHand().get(cardIndex));
                current.getHand().remove(cardIndex);
                numItemsInPot++;
                multiplier = Math.abs(multiplier + 0.5);
            }
        }
    }

    public void seePot(){
        System.out.println(pot);
    }

    public long problems() {
        return Math.abs(Math.round(numItemsInPot * multiplier));
    }
}

public void gamble(Player current, int whichCard, String options) {
    switch(options){
      case "one" -> p.get(current, whichCard);
      case "two" -> p.getHandAmt(current, whichCard);
      case "all" -> p.getAll(current, whichCard);
    }
}
public Pot getPot(){
        p.seePot();
        return p;
}
case "4" ->{
  System.out.println("which card in your hand? (number left to right)");
  System.out.println(numSelectInput);
  System.out.println("how many? one) 1 two) everything in hand all) every version in deck and hand");
  String test = input.nextLine();
  current.gamble(current, numSelectInput, test);
}

"description":
  {
    "identifier": "format:Plain_Tree"
  },

Map<Integer, List<String>> cardIDPositionMap;
Map<String, List<String>> typeToPositionMap;
List<String> positions;
for(int j = 0; j < cookBook.length(); j++ ) {
    JSONObject tmpRecipe = cookBook.getJSONObject(j);
    JSONArray recipeIngredients = tmpRecipe.getJSONArray("ingredients");
    for(int k = 0; k < recipeIngredients.length(); k++){
        JSONObject tmpIngredients = recipeIngredients.getJSONObject(k);
        boolean needCard = tmpIngredients.getBoolean("cardCheck");
        boolean needType = tmpIngredients.getBoolean("typeCheck");
        JSONArray getPos = tmpIngredients.getJSONArray("position");

        if(!needCard && needType) {
          String tmpType = tmpIngredients.getString("type");

          for (int l = 0; l < getPos.length(); l++) {
              JSONObject tmpPos = getPos.getJSONObject(l);
          }
       }
   }
}
 "skills": [
    {
      "_comment": "type_based_cards",

      "card": {"name": "Blank", "cardID": -1, "skillType": "type", "typeCheck": "NEUTRAL", "modValueAtk": 0, "modValueDef": 0}
    },
    {
      "_comment": "type-position_based_cards",

      "card": {"name": "Apple", "cardID": 6, "skillType": "type-position", "typeCheck": "PLANT", "posCheck": "CORE", "modValueAtk": 0, "modValueDef": 1}
    },
    {
      "card": {"name": "Cornflower", "cardID": 10, "skillType": "type-position", "typeCheck": "FLOWER", "posCheck": "CORE", "modValueAtk": 1, "modValueDef": 0}
    },
    {
      "card": {
        "name": "Mutton",
        "cardID": 7,
        "skillType": "type-position",
        "typeCheck": "ANIMAL",
        "posCheck": "CORE",
        "modValueAtk": 2,
        "modValueDef": 0
      }
    },
    {
      "_comment": "card_based_cards",

      "name": "HayBale",
      "cardID": 8,
      "skillType": "card",
      "cardIDCheck": 31,
      "modValueAtk": 1,
      "modValueDef": 1
    }
  ]

}
Calculation p1 = new Calculation(one, two);
Calculation p2 = new Calculation( two, one);

            if(p1.calculate()){
                System.out.println("Player 1 Wins");
                isWinner = p1.calculate();
            }else if(p2.calculate()){
                System.out.println("Player 2 Wins");
                isWinner = p2.calculate();
            }
int tally = 0;
        for(int i = 0; i < 4; i++){
            for(int j = 0; j < 3; j++){
                if(board_Grid[i][j].isEmpty()){
                    tally++;
                }
            }
        }
package Game.Slots;

import java.io.FileReader;
import java.io.IOException;

import Game.*;
import org.json.JSONArray;
import org.json.JSONObject;

import Game.Player;
import static Game.Slots.Board.Board_Positions.*;

public class Calculation {

    //numbers for final use
    private int uTotalATK, aTotalATK, cdTotalATK, dTotalATK; // only need one set bc it'll switch outside then start this again
    private int uTotalDEF, aTotalDEF, cdTotalDEF, dTotalDEF;

    public Calculation(Player first, Player second) throws IOException {
        Board one = first.getBoard();
        Board two = second.getBoard();

        //get the core stats for later
        int coreATKMod1, coreDEFMod2;
        if(one.getGrid()[2][1] == null){
            coreATKMod1 = 0;
        }else { coreATKMod1 = one.getGrid()[2][1].getAtk(); }

        if(two.getGrid()[2][1] == null) {
            coreDEFMod2 = 0;
        } else{ coreDEFMod2 = two.getGrid()[2][1].getDef(); }

        int overflow;

        //fileReader to get the file then a while loop to build a string from it
        try(FileReader modReader = new FileReader("C:\\Users\\sensa\\IdeaProjects\\testGame\\src\\Game\\CardData\\Modifier.json")) {
            StringBuilder modString = new StringBuilder(" ");
            int i;
            while ((i = modReader.read()) != -1) {
                //System.out.print((char)i);
                modString.append((char) i);
            }
            JSONObject jsonMODObject = new JSONObject(modString.toString());
            JSONArray skillList = (JSONArray) jsonMODObject.get("skills");

            //go through skillList, if the id matches card on board get mod numbers according to things (card type, whatever)
            boolean done = false;
            Board current, other;
            current = one;
            other = two;
            int l = 0;
            while (!done) {
                for (int j = 0; j < skillList.length(); j++) {
                    JSONObject tmp = skillList.getJSONObject(j);
                    int tmpI = tmp.getInt("cardID");
                    for (int k = 0; k < current.getGrid().length; k++) {
                        if(current.isBoardEmpty()) {
                            if (tmpI == current.getGrid()[j][k].getSlot().getId() && !current.getGrid()[j][k].getSlot().isItem()) {
                                //check the skill type
                                checkSkillsATK(tmp, tmp.getString("skillType"), current); // attacker then defence
                            }
                        }
                    }
                    for (int k = 0; k < other.getGrid().length; k++) {
                        if(other.isBoardEmpty()) {
                            if (tmpI == other.getGrid()[j][k].getSlot().getId() && !other.getGrid()[j][k].getSlot().isItem()) {
                                //check the skill type
                                checkSkillsDEF(tmp, tmp.getString("skillType"), other);
                            }
                        }
                    }

                }
                current = switchBoard(current, one, two);
                if (current == one) {
                    other = two;
                } else if (current == two) {
                    other = one;
                }

                if (current == two && l > 0) {
                    done = true;
                }
                l++;
            }
        } catch (IOException ex){
            throw new IOException("Something Has Failed");

        } finally {
            System.out.println("Everything went perfectly... be very afraid");
        }
        //overflow calculations + core additions
        overflow = uTotalDEF - uTotalATK; // uber gets no overflow
        if(overflow > 0){
            uTotalATK = uTotalATK + overflow + coreATKMod1;
        }else{ uTotalATK = uTotalATK + coreATKMod1;}

        overflow = aTotalDEF - aTotalATK;
        if(overflow > 0){
            cdTotalATK = cdTotalATK + overflow + coreATKMod1;
        }else { cdTotalATK = cdTotalATK + coreATKMod1;}

        overflow = cdTotalDEF - cdTotalATK;
        if(overflow > 0){
            dTotalATK = dTotalATK + overflow + coreATKMod1;
        }else{dTotalATK = dTotalATK + coreATKMod1;}

        //defence core additions
        uTotalDEF = uTotalDEF + coreDEFMod2;
        aTotalDEF = aTotalDEF + coreDEFMod2;
        cdTotalDEF = cdTotalDEF + coreDEFMod2;
        dTotalDEF = dTotalDEF + coreDEFMod2;
    }

    public boolean calculate(){ //if true game ends if false game continues
        return uTotalATK > uTotalDEF && aTotalATK > aTotalDEF && cdTotalATK > cdTotalDEF && dTotalATK > dTotalDEF;
    }
//move everything here then trash the rest
    private Board switchBoard(Board current, Board one, Board two) {
        if (current == one) {
            current = two;
            System.out.println("Player two");
            return current;
        }
        if (current == two) {
            current = one;
            System.out.println("Player one");
            return current;

        }
        return current;
    }
    private void checkSkillsATK(JSONObject o,String skillTypeBase, Board attacker){
        switch(skillTypeBase){
            case "type" -> {
                String typeC = o.getString("typeCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(attacker.getGrid()[n][i].isEmpty()) {
                            if (attacker.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[0][i].currentPlace() == UBER || attacker.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueAtk");
                                uTotalATK = uTotalATK + tno;
                            }
                            if (attacker.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[1][i].currentPlace() == ATTACK || attacker.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueAtk");
                                aTotalATK = aTotalATK + tno;
                            }
                            if (attacker.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE || attacker.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                cdTotalATK = cdTotalATK + tno;
                            }
                            if (attacker.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE || attacker.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                dTotalATK = dTotalATK + tno;
                            }
                        }
                    }
                }
            } //get the typeCheck then go through current board. for each card w/ type add mod, return total
            case "type-position" -> {
                String typeC = o.getString("typeCheck");
                String posC = o.getString("posCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(attacker.getGrid()[n][i].isEmpty()) {
                            if (attacker.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[0][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[0][i].currentPlace() == UBER || attacker.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[0][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueAtk");
                                uTotalATK = uTotalATK + tno;
                            }
                            if (attacker.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[1][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[1][i].currentPlace() == ATTACK || attacker.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[1][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueAtk");
                                aTotalATK = aTotalATK + tno;
                            }
                            if (attacker.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[n][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE || attacker.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[n][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                cdTotalATK = cdTotalATK + tno;
                            }
                            if (attacker.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(attacker.getGrid()[3][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE || attacker.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(attacker.getGrid()[3][i].currentPlace()).contentEquals(posC) && attacker.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                dTotalATK = dTotalATK + tno;
                            }
                        }
                    }
                }
            } //get typeCheck and posCheck, go through current board, return total
            case "card" -> {
                int cID = o.getInt("cardID");
                for(int i = 0; i < 4; i++){
                    for(int j = 0; j < 3; j++){
                        if(attacker.getGrid()[i][j].isEmpty()) {
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == UBER) {
                                int tno = o.getInt("modValueAtk");
                                uTotalATK = uTotalATK + tno;
                            }
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueAtk");
                                aTotalATK = aTotalATK + tno;
                            }
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                cdTotalATK = cdTotalATK + tno;
                            }
                            if (attacker.getGrid()[i][j].getSlot().getId() == cID && attacker.getGrid()[i][j].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueAtk");
                                dTotalATK = dTotalATK + tno;
                            }
                        }
                    }
                }
            }//get cardIDCheck, if card there add mod
        }
    }
    private void checkSkillsDEF(JSONObject o,String skillTypeBase, Board defender){
        switch(skillTypeBase){
            case "type" -> {
                String typeC = o.getString("typeCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(defender.getGrid()[n][i].isEmpty()) {
                            if (defender.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[0][i].currentPlace() == UBER || defender.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueDef");
                                uTotalDEF = uTotalDEF + tno;
                            }
                            if (defender.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[1][i].currentPlace() == ATTACK || defender.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueDef");
                                aTotalDEF = aTotalDEF + tno;
                            }
                            if (defender.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE || defender.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueDef");
                                cdTotalDEF = cdTotalDEF + tno;
                            }
                            if (defender.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && defender.getGrid()[3][i].currentPlace() == DEFENCE || defender.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && defender.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueDef");
                                dTotalDEF = dTotalDEF + tno;
                            }
                        }
                    }
                }
            } //get the typeCheck then go through current board. for each card w/ type add mod, return total
            case "type-position" -> {
                String typeC = o.getString("typeCheck");
                String posC = o.getString("posCheck");
                for(int n = 0; n < 4; n++) {
                    for (int i = 0; i < 3; i++) {
                        if(defender.getGrid()[n][i].isEmpty()) {
                            if (defender.getGrid()[0][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[0][i].currentPlace()).contentEquals(posC) && defender.getGrid()[0][i].currentPlace() == UBER || defender.getGrid()[0][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[0][i].currentPlace()).contentEquals(posC) && defender.getGrid()[0][i].currentPlace() == UBER) {
                                int tno = o.getInt("modValueDef");
                                uTotalDEF = uTotalDEF + tno;
                            }
                            if (defender.getGrid()[1][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[1][i].currentPlace()).contentEquals(posC) && defender.getGrid()[1][i].currentPlace() == ATTACK || defender.getGrid()[1][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[1][i].currentPlace()).contentEquals(posC) && defender.getGrid()[1][i].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueDef");
                                aTotalDEF = aTotalDEF + tno;
                            }
                            if (defender.getGrid()[n][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[n][i].currentPlace()).contentEquals(posC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE || defender.getGrid()[n][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[n][i].currentPlace()).contentEquals(posC) && defender.getGrid()[n][i].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueDef");
                                cdTotalDEF = cdTotalDEF + tno;
                            }
                            if (defender.getGrid()[3][i].getSlot().activeTypeOne().equals(typeC) && String.valueOf(defender.getGrid()[3][i].currentPlace()).contentEquals(posC) && defender.getGrid()[3][i].currentPlace() == DEFENCE || defender.getGrid()[3][i].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(defender.getGrid()[3][i].currentPlace()).contentEquals(posC) && defender.getGrid()[3][i].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueDef");
                                dTotalDEF = dTotalDEF + tno;
                            }
                        }
                    }
                }
            } //get typeCheck and posCheck, go through current board, return total
            case "card" -> {
                int cID = o.getInt("cardID");
                for(int i = 0; i < 4; i++){
                    for(int j = 0; j < 3; j++){
                        if(defender.getGrid()[i][j].isEmpty()) {
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == UBER) {
                                int tno = o.getInt("modValueDef");
                                uTotalDEF = uTotalDEF + tno;
                            }
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == ATTACK) {
                                int tno = o.getInt("modValueDef");
                                aTotalDEF = aTotalDEF + tno;
                            }
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == CoreDEFENCE) {
                                int tno = o.getInt("modValueDef");
                                cdTotalDEF = cdTotalDEF + tno;
                            }
                            if (defender.getGrid()[i][j].getSlot().getId() == cID && defender.getGrid()[i][j].currentPlace() == DEFENCE) {
                                int tno = o.getInt("modValueDef");
                                dTotalDEF = dTotalDEF + tno;
                            }
                        }
                    }
                }
            }//get cardIDCheck, if card there add mod
        }
    }

    public static void main(String[] args) throws IOException {
        Player b = new Human();
        Player bb = new Human();

        Calculation c = new Calculation(b, bb);
        c.calculate();
    }
}

uberRow[0] = board_Grid[0][0].getAtk() + board_Grid[0][1].getAtk() + board_Grid[0][2].getAtk();
uberRow[1] = board_Grid[0][0].getDef() + board_Grid[0][1].getDef() + board_Grid[0][2].getDef();
        enemy.getUberRow()[0] = enemy.getGrid()[0][0].getAtk() + enemy.getGrid()[0][1].getAtk() + enemy.getGrid()[0][2].getAtk();
        enemy.getUberRow()[1] = enemy.getGrid()[0][0].getDef() + enemy.getGrid()[0][1].getDef() + enemy.getGrid()[0][2].getDef();
        atkRow[0] = board_Grid[1][0].getAtk() + board_Grid[1][2].getAtk();
        atkRow[1] = board_Grid[1][0].getDef() + board_Grid[1][2].getDef();
        enemy.getAtkRow()[0] = enemy.getGrid()[1][0].getAtk() + enemy.getGrid()[1][2].getAtk();
        enemy.getAtkRow()[1] = enemy.getGrid()[1][0].getDef() + enemy.getGrid()[1][2].getDef();
        cDefRow[0] = board_Grid[1][1].getAtk() + board_Grid[2][0].getAtk() + board_Grid[2][2].getAtk();
        cDefRow[1] = board_Grid[1][1].getDef() + board_Grid[2][0].getDef() + board_Grid[2][2].getDef();
        enemy.getCDefRow()[0] = enemy.getGrid()[1][1].getAtk() + enemy.getGrid()[2][0].getAtk() + enemy.getGrid()[2][2].getAtk();
        enemy.getCDefRow()[1] = enemy.getGrid()[1][1].getDef() + enemy.getGrid()[2][0].getDef() + enemy.getGrid()[2][2].getDef();
        coreBlock[0] = board_Grid[2][1].getAtk();
        coreBlock[1] = board_Grid[2][1].getDef();
        enemy.getCoreBlock()[0] = enemy.getGrid()[2][1].getAtk();
        enemy.getCoreBlock()[1] = enemy.getGrid()[2][1].getDef();
        defRow[0] = board_Grid[3][0].getAtk() + board_Grid[3][1].getAtk() + board_Grid[3][2].getAtk();
        defRow[1] = board_Grid[3][0].getDef() + board_Grid[3][1].getDef() + board_Grid[3][2].getDef();
        enemy.getDefRow()[0] = enemy.getGrid()[3][0].getAtk() + enemy.getGrid()[3][1].getAtk() + enemy.getGrid()[3][2].getAtk();
        enemy.getDefRow()[1] = enemy.getGrid()[3][0].getDef() + enemy.getGrid()[3][1].getDef() + enemy.getGrid()[3][2].getDef();

uberRow = new int[2];
atkRow = new int[2];
cDefRow = new int[2];
coreBlock = new int[2];
defRow = new int[2];

<!--    me trying not to do work-->
<script src = "../src/Game" crossorigin="anonymous"></script>
<script src = "../src/Game/Slots" crossorigin="anonymous"></script>
<script src = "../src/Game/Slots/Board.java" crossorigin="anonymous"></script>
<script src = "../src/Game/Slots/Positions.java" crossorigin="anonymous"></script>
<script src = "../src/Game/Card.java" crossorigin="anonymous"></script>
<script src = "../src/Game/cardDatabase.java" crossorigin="anonymous"></script>
<script src = "../src/Game/ComboBuild.java" crossorigin="anonymous"></script>
<script src = "../src/Game/Human.java" crossorigin="anonymous"></script>
<script src = "../src/Game/ItemSkills.java" crossorigin="anonymous"></script>
<script src = "../src/Game/Player.java" crossorigin="anonymous"></script>

// Generated JS from Java: Game.cardDatabase -----
function Game_cardDatabase() {
   this.pack = null;
   this.formPack = null;
   jv_Object.call(this);
   this._Game_cardDatabaseInit();
}

var Game_cardDatabase_c = sc_newClass("Game.cardDatabase", Game_cardDatabase, jv_Object, null);

Game_cardDatabase_c.cardData = function ()  {
   this.pack.add(new Card(-1, "Blank", sc_initArray(Number_c, 1, [ 0, 0 ]),
              sc_initArray(Number_c, 1, [ 0, 0 ]), sc_initArray(Number_c, 1, [ 0, 0 ]),
              sc_initArray(Number_c, 1, [ 0, 0 ]), sc_initArray(Number_c, 1, [ 0, 0 ]),
              "NEUTRAL", "NEUTRAL"));
   this.pack.add(new Card(0, "Basic_Seeds", sc_initArray(Number_c, 1, [ 4, 2 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 1, 4 ]),
              "PLANT", "FARM"));
   this.pack.add(new Card(1, "Simple_Axe", sc_initArray(Number_c, 1, [ 4, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 3, 5 ]), sc_initArray(Number_c, 1, [ 2, 4 ]),
              "TOOL", "NEUTRAL"));
   this.pack.add(new Card(2, "Feather", sc_initArray(Number_c, 1, [ 3, 1 ]),
              sc_initArray(Number_c, 1, [ 3, 1 ]), sc_initArray(Number_c, 1, [ 4, 2 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 5, 3 ]),
              "ANIMAL", "FARM"));
   this.pack.add(new Card(3, "Flaccid_Flower", sc_initArray(Number_c, 1, [ 2, 1 ]),
              sc_initArray(Number_c, 1, [ 1, 1 ]), sc_initArray(Number_c, 1, [ 1, 3 ]),
              sc_initArray(Number_c, 1, [ 1, 3 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              "FLOWER", "PLANT"));
   this.pack.add(new Card(4, "Gourd_Seeds", sc_initArray(Number_c, 1, [ 1, 4 ]),
              sc_initArray(Number_c, 1, [ 1, 4 ]), sc_initArray(Number_c, 1, [ 2, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              "PLANT", "FARM"));
   this.pack.add(new Card(5, "Pumpkin", sc_initArray(Number_c, 1, [ 2, 5 ]),
              sc_initArray(Number_c, 1, [ 2, 5 ]), sc_initArray(Number_c, 1, [ 3, 5 ]),
              sc_initArray(Number_c, 1, [ 3, 5 ]), sc_initArray(Number_c, 1, [ 3, 5 ]),
              "PLANT", "FARM"));
   this.pack.add(new Card(6, "Apple", sc_initArray(Number_c, 1, [ 3, 2 ]),
              sc_initArray(Number_c, 1, [ 3, 2 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              "PLANT", "FARM"));
   this.pack.add(new Card(7, "Mutton", sc_initArray(Number_c, 1, [ 4, 1 ]),
              sc_initArray(Number_c, 1, [ 3, 2 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              "ANIMAL", "FARM"));
   this.pack.add(new Card(8, "HayBale", sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 2, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 2, 5 ]),
              "PLANT", "FARM"));
   this.pack.add(new Card(9, "Shears", sc_initArray(Number_c, 1, [ 3, 1 ]),
              sc_initArray(Number_c, 1, [ 2, 1 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              "ANIMAL", "FARM"));
   this.pack.add(new Card(10, "Cornflower", sc_initArray(Number_c, 1, [ 2, 1 ]),
              sc_initArray(Number_c, 1, [ 2, 1 ]), sc_initArray(Number_c, 1, [ 1, 1 ]),
              sc_initArray(Number_c, 1, [ 1, 1 ]), sc_initArray(Number_c, 1, [ 1, 1 ]),
              "FLOWER", "FARM"));
   this.pack.add(new Card(11, "Sapling", sc_initArray(Number_c, 1, [ 3, 1 ]),
              sc_initArray(Number_c, 1, [ 2, 1 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              "PLANT", "WOOD"));
   this.pack.add(new Card(12, "Door", sc_initArray(Number_c, 1, [ 2, 1 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 3 ]), sc_initArray(Number_c, 1, [ 1, 3 ]),
              "ITEM", "WOOD"));
   this.pack.add(new Card(14, "Jeweled_Axe", sc_initArray(Number_c, 1, [ 5, 1 ]),
              sc_initArray(Number_c, 1, [ 5, 1 ]), sc_initArray(Number_c, 1, [ 4, 2 ]),
              sc_initArray(Number_c, 1, [ 4, 2 ]), sc_initArray(Number_c, 1, [ 4, 2 ]),
              "TOOL", "LUCKY"));
   this.pack.add(new Card(15, "Simple Spade", sc_initArray(Number_c, 1, [ 2, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 4 ]), sc_initArray(Number_c, 1, [ 3, 2 ]),
              "TOOL", "NEUTRAL"));
   this.pack.add(new Card(16, "Fishing_Rod", sc_initArray(Number_c, 1, [ 1, 1 ]),
              sc_initArray(Number_c, 1, [ 1, 1 ]), sc_initArray(Number_c, 1, [ 1, 1 ]),
              sc_initArray(Number_c, 1, [ 1, 1 ]), sc_initArray(Number_c, 1, [ 1, 1 ]),
              "ITEM", "TOOL"));
   this.pack.add(new Card(19, "Iron", sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "METAL", "NEUTRAL"));
   this.pack.add(new Card(20, "Iron_Ore", sc_initArray(Number_c, 1, [ 1, 1 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 1, 1 ]),
              "ORE", "METAL"));
   this.pack.add(new Card(21, "Planks", sc_initArray(Number_c, 1, [ 3, 2 ]),
              sc_initArray(Number_c, 1, [ 3, 2 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              "PLANT", "WOOD"));
   this.pack.add(new Card(22, "Water_Bucket", sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "ITEM", "FARM"));
   this.pack.add(new Card(23, "Gold", sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "METAL", "NEUTRAL"));
   this.pack.add(new Card(24, "Anvil", sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 4, 3 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 3, 4 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "TOOL", "METAL"));
   this.pack.add(new Card(25, "NameTag", sc_initArray(Number_c, 1, [ 1, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 1, 2 ]),
              "ITEM", "NEUTRAL"));
   this.pack.add(new Card(28, "Furnace", sc_initArray(Number_c, 1, [ 2, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 4, 4 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "TOOL", "NEUTRAL"));
   this.pack.add(new Card(29, "Trident", sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "WATER", "TOOL"));
   this.pack.add(new Card(30, "Healing_Potion", sc_initArray(Number_c, 1, [ 0, 1 ]),
              sc_initArray(Number_c, 1, [ 0, 1 ]), sc_initArray(Number_c, 1, [ 1, 3 ]),
              sc_initArray(Number_c, 1, [ 1, 3 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              "ITEM", "NEUTRAL"));
   this.pack.add(new Card(31, "Wheat", sc_initArray(Number_c, 1, [ 2, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 2, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 2, 3 ]),
              "PLANT", "FARM"));
   this.pack.add(new Card(32, "Coral", sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 4, 4 ]), sc_initArray(Number_c, 1, [ 4, 5 ]),
              "WATER", "PLANT"));
   this.pack.add(new Card(33, "Kelp", sc_initArray(Number_c, 1, [ 2, 4 ]),
              sc_initArray(Number_c, 1, [ 3, 4 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 4, 4 ]),
              "WATER", "PLANT"));
   this.pack.add(new Card(35, "Aquamarine", sc_initArray(Number_c, 1, [ 2, 3 ]),
              sc_initArray(Number_c, 1, [ 3, 3 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 4, 4 ]), sc_initArray(Number_c, 1, [ 4, 5 ]),
              "WATER", "METAL"));
   this.pack.add(new Card(36, "Gold_Ore", sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 1 ]), sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 2, 2 ]),
              "ORE", "NEUTRAL"));
   this.pack.add(new Card(37, "Poppy", sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 2, 2 ]), sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 1 ]), sc_initArray(Number_c, 1, [ 2, 2 ]),
              "FLOWER", "NEUTRAL"));
   this.pack.add(new Card(38, "Dandelion", sc_initArray(Number_c, 1, [ 3, 2 ]),
              sc_initArray(Number_c, 1, [ 3, 2 ]), sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 2, 1 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "FLOWER", "NEUTRAL"));
   this.pack.add(new Card(39, "Raw_Steak", sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 3 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              "ANIMAL", "FARM"));
   this.pack.add(new Card(40, "Wool", sc_initArray(Number_c, 1, [ 2, 2 ]),
              sc_initArray(Number_c, 1, [ 1, 2 ]), sc_initArray(Number_c, 1, [ 3, 3 ]),
              sc_initArray(Number_c, 1, [ 2, 4 ]), sc_initArray(Number_c, 1, [ 3, 4 ]),
              "FARM", "ANIMAL"));
   this.pack.add(new Card(41, "Newton's_Apple", sc_initArray(Number_c, 1, [ 4, 2 ]),
              sc_initArray(Number_c, 1, [ 3, 1 ]), sc_initArray(Number_c, 1, [ 3, 1 ]),
              sc_initArray(Number_c, 1, [ 4, 4 ]), sc_initArray(Number_c, 1, [ 1, 1 ]),
              "PLANT", "LUCKY"));
};
Game_cardDatabase_c.formData = function ()  {
   this.formPack.add(new ComboBuild(17, "Tree", sc_initArray(Number_c, 1, [ 2, 4 ]), "PLANT"));
   this.formPack.add(new ComboBuild(18, "Flower_Bush", sc_initArray(Number_c, 1, [ 2, 2 ]), "FLOWER"));
   this.formPack.add(new ComboBuild(26, "Item_Frame", sc_initArray(Number_c, 1, [ 2, 2 ]), "TOOL"));
   this.formPack.add(new ComboBuild(27, "Stairs", sc_initArray(Number_c, 1, [ 1, 1 ]), "TOOL"));
   this.formPack.add(new ComboBuild(34, "Ocean_Monument", sc_initArray(Number_c, 1, [ 3, 3 ]), "WATER"));
   this.formPack.add(new ComboBuild(42, "Apple_Pie", sc_initArray(Number_c, 1, [ 5, 5 ]), "NEUTRAL"));
};

Game_cardDatabase_c._Game_cardDatabaseInit = function() {
   this.pack = new jv_ArrayList();
      ;
   this.formPack = new jv_ArrayList();
      ;
};

<!-- <script src = "../src/Game/CardData/card_image.json" crossorigin="anonymous"></script>
<script src = "../src/Game/CardData/Evolutions.json" crossorigin="anonymous"></script>
<script src = "../src/Game/CardData/Formation_Recipes.json" crossorigin="anonymous"></script>
<script src = "../src/Game/CardData/Modifier.json" crossorigin="anonymous"></script> -->

public void calculate(){
    for(int f = 0; f < 2; f++){
        for(int r = 0; r < 3; r++){
            if(board_Grid[0][r] != null){
                if(f == 0) {
                    uberRow[f] = uberRow[f] + board_Grid[0][r].getAtk();
                } else{
                    uberRow[f] = uberRow[f] + board_Grid[0][r].getDef();
                }
            }
            if(enemy.getGrid()[0][r] != null){
                if(f == 0) {
                    enemy.getUberRow()[f] = enemy.getUberRow()[f] + enemy.getGrid()[0][r].getAtk();
                } else{
                    enemy.getUberRow()[f] = enemy.getUberRow()[f] + enemy.getGrid()[0][r].getDef();
                }
            }

            if(board_Grid[3][r] != null){
                if(f == 0) {
                    defRow[f] = defRow[f] + board_Grid[3][r].getAtk();
                } else{
                    defRow[f] = defRow[f] + board_Grid[3][r].getDef();
                }
            }
            if(enemy.getGrid()[3][r] != null){
                if(f == 0) {
                    enemy.getDefRow()[f] = enemy.getDefRow()[f] + enemy.getGrid()[3][r].getAtk();
                } else{
                    enemy.getDefRow()[f] = enemy.getDefRow()[f] + enemy.getGrid()[3][r].getDef();
                }
            }

        }
    }
    if(board_Grid[1][0] != null){
        atkRow[0] = atkRow[0] + board_Grid[1][0].getAtk();
        atkRow[1] = atkRow[1] +board_Grid[1][0].getDef();
    }
    if(board_Grid[1][2] != null){
        atkRow[0] = atkRow[0] + board_Grid[1][2].getAtk();
        atkRow[1] = atkRow[1] + board_Grid[1][2].getDef();
    }
    if(enemy.getGrid()[1][0] != null){
        enemy.getAtkRow()[0] = enemy.getGrid()[1][0].getAtk() + enemy.getAtkRow()[0];
        enemy.getAtkRow()[1] = enemy.getGrid()[1][0].getDef() + enemy.getAtkRow()[1];
    }
    if(enemy.getGrid()[1][2] != null){
        enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + enemy.getGrid()[1][2].getAtk();
        enemy.getAtkRow()[1] = enemy.getAtkRow()[1] + enemy.getGrid()[1][2].getDef();
    }

    if(board_Grid[1][1] != null) {
        cDefRow[0] = board_Grid[1][1].getAtk() + cDefRow[0];
        cDefRow[1] = board_Grid[1][1].getDef() + cDefRow[1];
    }
    if(board_Grid[2][0] != null){
        cDefRow[0] = board_Grid[2][0].getAtk() + cDefRow[0];
        cDefRow[1] = board_Grid[2][0].getDef() + cDefRow[1];
    }
    if(board_Grid[2][2] != null){
        cDefRow[0] = cDefRow[0] + board_Grid[2][2].getAtk();
        cDefRow[1] = cDefRow[1] + board_Grid[2][2].getDef();
    }
    if(enemy.getGrid()[1][1] != null) {
        enemy.getCDefRow()[0] = enemy.getGrid()[1][1].getAtk() + enemy.getCDefRow()[0];
        enemy.getCDefRow()[1] = enemy.getGrid()[1][1].getDef() + enemy.getCDefRow()[1];
    }
    if(enemy.getGrid()[2][0] != null){
        enemy.getCDefRow()[0] = enemy.getGrid()[2][0].getAtk() + enemy.getCDefRow()[0];
        enemy.getCDefRow()[1] = enemy.getGrid()[2][0].getDef() + enemy.getCDefRow()[1];
    }
    if(enemy.getGrid()[2][2] != null){
        enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + enemy.getGrid()[2][2].getAtk();
        enemy.getCDefRow()[1] = enemy.getCDefRow()[1] + enemy.getGrid()[2][2].getDef();
    }

    if(board_Grid[2][1] != null){
        coreBlock[0] = board_Grid[2][1].getAtk();
        coreBlock[1] = board_Grid[2][1].getDef();
    }
    if(enemy.getGrid()[2][1] != null) {
        enemy.getCoreBlock()[0] = enemy.getGrid()[2][1].getAtk();
        enemy.getCoreBlock()[1] = enemy.getGrid()[2][1].getDef();
    }

    try(FileReader modReader = new FileReader("C:\\Users\\sensa\\IdeaProjects\\testGame\\src\\Game\\CardData\\Modifier.json")) {
        StringBuilder modString = new StringBuilder(" ");
        int i;
        while ((i = modReader.read()) != -1) {
            //System.out.print((char)i);
            modString.append((char) i);
        }
        JSONObject jsonMODObject = new JSONObject(modString.toString());
        JSONObject dList = jsonMODObject.getJSONObject("deck");
        JSONArray skillList = (JSONArray) dList.get("cards");

        for (int j = 0; j < skillList.length(); j++) {
            JSONObject cList = skillList.getJSONObject(j);

            int cID = cList.getInt("cardID");
            String typeBase = cList.getString("skillType");
            //if cID == card in row add mod value

            switch (typeBase) {
                case "type" -> {
                    int mAtk = cList.getInt("modValueAtk");
                    int mDef = cList.getInt("modValueDef");

                    String tC = cList.getString("typeCheck");
                    int tik = 0;

                    for(int l = 0; l < 4; l++){
                        for (int o = 0; o < 3; o++) {
                            if(board_Grid[l][o] != null) {
                                if (board_Grid[l][o].getSlot().activeTypeOne().equals(tC) || board_Grid[l][o].getSlot().activeTypeTwo().equals(tC)) {
                                    tik++;
                                }
                            }
                        }
                    }
                    for (int k = 0; k < 3; k++) {
                        if (board_Grid[0][k] != null && cID == board_Grid[0][k].getSlot().getId()) {
                            uberRow[0] = uberRow[0] + mAtk;
                            uberRow[1] = uberRow[1] + mDef;
                        }
                        if (board_Grid[1][0] != null && cID == board_Grid[1][0].getSlot().getId()  || board_Grid[1][2] != null && cID == board_Grid[1][2].getSlot().getId()) {
                            atkRow[0] = atkRow[0] + mAtk;
                            atkRow[1] = atkRow[1] + mDef;
                        }
                        if (board_Grid[1][1] != null && cID == board_Grid[1][1].getSlot().getId() || board_Grid[2][0] != null && cID == board_Grid[2][0].getSlot().getId() || board_Grid[2][2] != null && cID == board_Grid[2][2].getSlot().getId()) {
                            cDefRow[0] = cDefRow[0] + mAtk;
                            cDefRow[1] = cDefRow[1] + mDef;
                        }

                        if (board_Grid[3][k] != null && cID == board_Grid[3][k].getSlot().getId()) {
                            defRow[0] = defRow[0] + mAtk;
                            defRow[1] = defRow[1] + mDef;
                        }

                    }

                    tik = 0;
                    for(int l = 0; l < 4; l++){
                        for (int o = 0; o < 3; o++) {
                            if(enemy.getGrid()[l][o] != null) {
                                if (enemy.getGrid()[l][o].getSlot().activeTypeOne().equals(tC) || enemy.getGrid()[l][o].getSlot().activeTypeTwo().equals(tC)) {
                                    tik++;
                                }
                            }
                        }
                    }
                    for (int k = 0; k < tik; k++) {
                        if (enemy.getGrid()[0][k] != null && cID == enemy.getGrid()[0][k].getSlot().getId()) {
                            enemy.getUberRow()[0] = enemy.getUberRow()[0] + mAtk;
                            enemy.getUberRow()[1] = enemy.getUberRow()[1] + mDef;
                        }
                        if (enemy.getGrid()[1][0] != null && cID == enemy.getGrid()[1][0].getSlot().getId() || enemy.getGrid()[1][2] != null && cID == enemy.getGrid()[1][2].getSlot().getId()) {
                            enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + mAtk;
                            enemy.getAtkRow()[1] = enemy.getAtkRow()[1] + mDef;
                        }
                        if (enemy.getGrid()[1][1] != null && cID == enemy.getGrid()[1][1].getSlot().getId() || enemy.getGrid()[2][0] != null && cID == enemy.getGrid()[2][0].getSlot().getId() || enemy.getGrid()[2][2] != null && cID == enemy.getGrid()[2][2].getSlot().getId()) {
                            enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + mAtk;
                            enemy.getCDefRow()[1] = enemy.getCDefRow()[1] + mDef;
                        }
                        if (enemy.getGrid()[3][k] != null && cID == enemy.getGrid()[3][k].getSlot().getId()) {
                            enemy.getDefRow()[0] = enemy.getDefRow()[0] + mAtk;
                            enemy.getDefRow()[1] = enemy.getDefRow()[1] + mDef;
                        }
                    }

                }
                case "position" -> {
                    int mAtk = cList.getInt("modValueAtk");
                    int mDef = cList.getInt("modValueDef");

                    String pC = cList.getString("posCheck");

                    for (int k = 0; k < 3; k++) {
                        if (board_Grid[0][k] != null && cID == board_Grid[0][k].getSlot().getId() && String.valueOf(board_Grid[0][k].currentPlace()).contentEquals(pC)) {
                            uberRow[0] = uberRow[0] + mAtk;
                            uberRow[1] = uberRow[1] + mDef;
                        }
                        if (board_Grid[1][0] != null && cID == board_Grid[1][0].getSlot().getId() && String.valueOf(board_Grid[1][0].currentPlace()).contentEquals(pC) || board_Grid[1][2] != null && cID == board_Grid[1][2].getSlot().getId() && String.valueOf(board_Grid[1][2].currentPlace()).contentEquals(pC)) {
                            atkRow[0] = atkRow[0] + mAtk;
                            atkRow[1] = atkRow[1] + mDef;
                        }
                        if (board_Grid[1][1] != null && cID == board_Grid[1][1].getSlot().getId() && String.valueOf(board_Grid[1][1].currentPlace()).contentEquals(pC) || board_Grid[2][0] != null && cID == board_Grid[2][0].getSlot().getId() && String.valueOf(board_Grid[2][0].currentPlace()).contentEquals(pC) || board_Grid[2][2] != null && cID == board_Grid[2][2].getSlot().getId() && String.valueOf(board_Grid[2][2].currentPlace()).contentEquals(pC)) {
                            cDefRow[0] = cDefRow[0] + mAtk;
                            cDefRow[1] = cDefRow[1] + mDef;
                        }
                        if (board_Grid[3][k] != null && cID == board_Grid[3][k].getSlot().getId() && String.valueOf(board_Grid[3][k].currentPlace()).contentEquals(pC)) {
                            defRow[0] = defRow[0] + mAtk;
                            defRow[1] = defRow[1] + mDef;
                        }

                    }

                    for (int k = 0; k < 3; k++) {
                        if (enemy.getGrid()[0][k] != null && cID == enemy.getGrid()[0][k].getSlot().getId() && String.valueOf(enemy.getGrid()[0][k].currentPlace()).contentEquals(pC)) {
                            enemy.getUberRow()[0] = enemy.getUberRow()[0] + mAtk;
                            enemy.getUberRow()[1] = enemy.getUberRow()[1] + mDef;
                        }
                        if (enemy.getGrid()[1][0] != null && cID == enemy.getGrid()[1][0].getSlot().getId() && String.valueOf(enemy.getGrid()[1][0].currentPlace()).contentEquals(pC) || enemy.getGrid()[1][2] != null && cID == enemy.getGrid()[1][2].getSlot().getId() && String.valueOf(enemy.getGrid()[1][2].currentPlace()).contentEquals(pC)) {
                            enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + mAtk;
                            enemy.getAtkRow()[1] = enemy.getAtkRow()[1] + mDef;
                        }
                        if (enemy.getGrid()[1][1] != null && cID == enemy.getGrid()[1][1].getSlot().getId() && String.valueOf(enemy.getGrid()[1][1].currentPlace()).contentEquals(pC) || enemy.getGrid()[2][0] != null && cID == enemy.getGrid()[2][0].getSlot().getId() && String.valueOf(enemy.getGrid()[2][0].currentPlace()).contentEquals(pC) || enemy.getGrid()[2][2] != null && cID == enemy.getGrid()[2][2].getSlot().getId() && String.valueOf(enemy.getGrid()[2][2].currentPlace()).contentEquals(pC)) {
                            enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + mAtk;
                            enemy.getCDefRow()[1] = enemy.getCDefRow()[1] + mDef;
                        }
                        if (enemy.getGrid()[3][k] != null && cID == enemy.getGrid()[3][k].getSlot().getId() && String.valueOf(enemy.getGrid()[3][k].currentPlace()).contentEquals(pC)) {
                            enemy.getDefRow()[0] = enemy.getDefRow()[0] + mAtk;
                            enemy.getDefRow()[1] = enemy.getDefRow()[1] + mDef;
                        }
                    }
                }
                case "type-position" -> {
                    String typeC = cList.getString("typeCheck");
                    String posC = cList.getString("posCheck");

                    int mAtk = cList.getInt("modValueAtk");
                    int mDef = cList.getInt("modValueDef");

                    for(int n = 0; n < 4; n++) {
                        for (int o = 0; o < 3; o++) {
                            if (board_Grid[n][o] != null) {
                                if (board_Grid[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == UBER || board_Grid[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == UBER) {
                                    uberRow[0] = uberRow[0] + mAtk;
                                    uberRow[1] = uberRow[1] + mDef;
                                }
                                if (board_Grid[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == ATTACK || board_Grid[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == ATTACK ) {
                                    atkRow[0] = atkRow[0] + mAtk;
                                    atkRow[1] = atkRow[1] + mDef;
                                }
                                if (board_Grid[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == CoreDEFENCE || board_Grid[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == CoreDEFENCE) {
                                    cDefRow[0] = cDefRow[0] + mAtk;
                                    cDefRow[1] = cDefRow[1] + mDef;
                                }
                                if (board_Grid[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == DEFENCE || board_Grid[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(board_Grid[n][o].currentPlace()).contentEquals(posC) && board_Grid[n][o].currentPlace() == DEFENCE) {
                                    defRow[0] = defRow[0] + mAtk;
                                    defRow[1] = defRow[1] + mDef;
                                }
                            }
                        }
                    }

                    for(int n = 0; n < 4; n++) {
                        for (int o = 0; o < 3; o++) {
                            if (enemy.getGrid()[n][o] != null) {
                                if (enemy.getGrid()[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == UBER || enemy.getGrid()[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == UBER) {
                                    uberRow[0] = uberRow[0] + mAtk;
                                    uberRow[1] = uberRow[1] + mDef;
                                }
                                if (enemy.getGrid()[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == ATTACK || enemy.getGrid()[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == ATTACK) {
                                    atkRow[0] = atkRow[0] + mAtk;
                                    atkRow[1] = atkRow[1] + mDef;
                                }
                                if (enemy.getGrid()[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == CoreDEFENCE || enemy.getGrid()[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == CoreDEFENCE) {
                                    cDefRow[0] = cDefRow[0] + mAtk;
                                    cDefRow[1] = cDefRow[1] + mDef;
                                }
                                if (enemy.getGrid()[n][o].getSlot().activeTypeOne().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == DEFENCE || enemy.getGrid()[n][o].getSlot().activeTypeTwo().equals(typeC) && String.valueOf(enemy.getGrid()[n][o].currentPlace()).contentEquals(posC) && enemy.getGrid()[n][o].currentPlace() == DEFENCE) {
                                    defRow[0] = defRow[0] + mAtk;
                                    defRow[1] = defRow[1] + mDef;
                                }
                            }
                        }
                    }

                }
                case "card" -> {
                    int cIDCheck = cList.getInt("cardIDCheck");

                    int mAtk = cList.getInt("modValueAtk");
                    int mDef = cList.getInt("modValueDef");

                    int tik = 0;

                    for(int l = 0; l < 4; l++){
                        for (int o = 0; o < 3; o++) {
                            if(board_Grid[l][o] != null) {
                                if (board_Grid[l][o].getSlot().getId() == cIDCheck) {
                                    tik++;
                                }
                            }
                        }
                    }
                    for (int k = 0; k < tik; k++) {
                        for(int l = 0; l < 4; l++){
                            for(int o = 0; o < 3; o++){
                                if(board_Grid[l][o] != null) {
                                    if (board_Grid[l][o].getSlot().getId() == cID && board_Grid[l][o].currentPlace() == UBER) {
                                        uberRow[0] = uberRow[0] + mAtk;
                                        uberRow[1] = uberRow[1] + mDef;
                                    }
                                    if (board_Grid[l][o].getSlot().getId() == cID && board_Grid[l][o].currentPlace() == ATTACK) {
                                        atkRow[0] = atkRow[0] + mAtk;
                                        atkRow[1] = atkRow[1] + mDef;
                                    }
                                    if (board_Grid[l][o].getSlot().getId() == cID && board_Grid[l][o].currentPlace() == CoreDEFENCE) {
                                        cDefRow[0] = cDefRow[0] + mAtk;
                                        cDefRow[1] = cDefRow[1] + mDef;
                                    }
                                    if (board_Grid[l][o].getSlot().getId() == cID && board_Grid[l][o].currentPlace() == DEFENCE) {
                                        defRow[0] = defRow[0] + mAtk;
                                        defRow[1] = defRow[1] + mDef;
                                    }
                                }
                            }
                        }

                    }

                    tik = 0;
                    for(int l = 0; l < 4; l++){
                        for (int o = 0; o < 3; o++) {
                            if(enemy.getGrid()[l][o] != null) {
                                if (enemy.getGrid()[l][o].getSlot().getId() == cIDCheck) {
                                    tik++;
                                }
                            }
                        }
                    }
                    for (int k = 0; k < tik; k++) {
                        for(int l = 0; l < 4; l++){
                            for(int o = 0; o < 3; o++) {
                                if (enemy.getGrid()[l][o] != null) {
                                    if (enemy.getGrid()[l][o].getSlot().getId() == cID && enemy.getGrid()[l][o].currentPlace() == UBER) {
                                        enemy.getUberRow()[0] = enemy.getUberRow()[0] + mAtk;
                                        enemy.getUberRow()[1] = enemy.getUberRow()[1] + mDef;
                                    }

                                    if (enemy.getGrid()[l][o].getSlot().getId() == cID && enemy.getGrid()[l][o].currentPlace() == ATTACK) {
                                        enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + mAtk;
                                        enemy.getAtkRow()[1] = enemy.getAtkRow()[1] + mDef;
                                    }

                                    if (enemy.getGrid()[l][o].getSlot().getId() == cID && enemy.getGrid()[l][o].currentPlace() == CoreDEFENCE) {
                                        enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + mAtk;
                                        enemy.getCDefRow()[1] = enemy.getCDefRow()[1] + mDef;
                                    }

                                    if (enemy.getGrid()[l][o].getSlot().getId() == cID && enemy.getGrid()[l][o].currentPlace() == DEFENCE) {
                                        enemy.getDefRow()[0] = enemy.getDefRow()[0] + mAtk;
                                        enemy.getDefRow()[1] = enemy.getDefRow()[1] + mDef;
                                    }
                                }
                            }
                        }
                    }

                }
            }
        }
    } catch (IOException ex){
        throw new IOException("Something Has Failed");
    }
    //add core
    for(int r = 0; r < 2; r++){ //0 is atk && 1 is def, so it sorts itself out
        uberRow[r] = uberRow[r] + coreBlock[r]; //atk
        enemy.getUberRow()[r] = enemy.getUberRow()[r] + enemy.getCoreBlock()[r];
        atkRow[r] = atkRow[r] + coreBlock[r];
        enemy.getAtkRow()[r] = enemy.getAtkRow()[r] + enemy.getCoreBlock()[r];
        cDefRow[r] = cDefRow[r] + coreBlock[r];
        enemy.getCDefRow()[r] = enemy.getCDefRow()[r] + enemy.getCoreBlock()[r];
        defRow[r] = defRow[r] + coreBlock[r];
        enemy.getDefRow()[r] = enemy.getDefRow()[r] + enemy.getCoreBlock()[r];
    }

    int overflowP1, overflowP2;
    overflowP2 = uberRow[1] - enemy.getUberRow()[0]; // uber gets no overflow
    overflowP1 = enemy.getUberRow()[1] - uberRow[0]; //p1 remainder from subtracting atk from enemy def
    int tmp1, tmp2; // the overflow goes once, so it needs to reset after

    if(overflowP1 > 0){
        atkRow[0] = atkRow[0] + overflowP1;
    }
    tmp1 = overflowP1;
    if(overflowP2 > 0){
        enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + overflowP2;
    }
    tmp2 = overflowP2;

    overflowP2 = atkRow[1] - (enemy.getAtkRow()[0] - tmp2);
    overflowP1 = enemy.getAtkRow()[1] - (atkRow[0] - tmp1) ;
    if(overflowP1 > 0){
        cDefRow[0] = cDefRow[0] + overflowP1;
    }
    tmp1 = overflowP1;
    if(overflowP2 > 0){
        enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + overflowP2;
    }
    tmp2 = overflowP2;

    overflowP2 = cDefRow[1] - (enemy.getCDefRow()[0] - tmp2);
    overflowP1 = enemy.getCDefRow()[1] - (cDefRow[0] - tmp1);
    if(overflowP1 > 0){
        defRow[0] = defRow[0] + overflowP1;
    }
    if(overflowP2 > 0){
        enemy.getDefRow()[0] = enemy.getDefRow()[0] + overflowP2;
    }

    //if board row is greater remove cards from other board vice versa
    //enemy lose action = take away cards
    if(uberRow[0] > enemy.getUberRow()[1] && uberRow[1] > enemy.getUberRow()[0]){
        for(int i = 0; i < 3; i++) {
            if(enemy.getGrid()[0][i] != null) {
                enemy.getGrid()[0][i].remove();
            }
        }
    } else if(uberRow[0] < enemy.getUberRow()[1] && uberRow[1] < enemy.getUberRow()[0]){
        for(int i = 0; i < 3; i++) {
            if(board_Grid[0][i] != null) {
                board_Grid[0][i].remove();
            }
        }
    }
    if(atkRow[0] > enemy.getAtkRow()[1] && atkRow[1] > enemy.getAtkRow()[0]){
        for(int i = 0; i < 3; i++) {
            if(enemy.getGrid()[1][i] != null && enemy.getGrid()[1][i].currentPlace() == ATTACK ){
                enemy.getGrid()[1][i].remove();
            }
        }
    } else if(uberRow[0] < enemy.getUberRow()[1] && uberRow[1] < enemy.getUberRow()[0]){
        for(int i = 0; i < 3; i++) {
            if(board_Grid[1][i] != null && board_Grid[1][i].currentPlace() == ATTACK ){
                board_Grid[1][i].remove();
            }
        }
    }
    if(cDefRow[0] > enemy.getCDefRow()[1] && cDefRow[1] > enemy.getCDefRow()[0]){
        for(int i = 1; i < 3; i++) {
            for(int j = 0; j < 3; j++) {
                if (enemy.getGrid()[i][j] != null && enemy.getGrid()[i][j].currentPlace() == CoreDEFENCE) {
                    enemy.getGrid()[i][j].remove();
                }
            }
        }
    } else if(cDefRow[0] < enemy.getCDefRow()[1] && cDefRow[1] < enemy.getCDefRow()[0]){
        for(int i = 1; i < 3; i++) {
            for(int j = 0; j < 3; j++) {
                if (board_Grid[i][j] != null && board_Grid[i][j].currentPlace() == CoreDEFENCE) {
                    board_Grid[i][j].remove();
                }
            }
        }
    }
    if(defRow[0] > enemy.getDefRow()[1] && defRow[1] > enemy.getDefRow()[0]){
        for(int i = 0; i < 3; i++) {
            if(enemy.getGrid()[3][i] != null) {
                enemy.getGrid()[3][i].remove();
            }
        }
    } else if(defRow[0] < enemy.getDefRow()[1] && defRow[1] < enemy.getDefRow()[0]){
        for(int i = 0; i < 3; i++) {
            if(board_Grid[3][i] != null){
                board_Grid[3][i].remove();
            }
        }
    }

 public void addToSlots(String name, Card fromHand) {
        System.out.println("Which slot in this position? (0-2)");
        Scanner input = new Scanner(System.in);
        int colChoice = input.nextInt();
        switch (name) {
            case "UBER" -> {
                //for each uber position on the grid //if there are less than uber open slot amount of uber positions
                if(board_Grid[0][colChoice] == null){
                    board_Grid[0][colChoice] = new Positions(UBER, fromHand);

                    int atk = board_Grid[0][colChoice].getAtk();
                    int def =board_Grid[0][colChoice].getDef();
                    getUberRow()[0] = getUberRow()[0] + atk;
                    getUberRow()[1] = getUberRow()[1] + def;
                }
            }
            case "ATTACK" -> {
                if(board_Grid[1][colChoice] == null ){ // only col 0 & 2
                    board_Grid[1][colChoice] = new Positions(ATTACK, fromHand);

                    int atk = board_Grid[1][colChoice].getAtk();
                    int def = board_Grid[1][colChoice].getDef();
                    getAtkRow()[0] = getAtkRow()[0] + atk;
                    getAtkRow()[1] = getAtkRow()[1] + def;
                }
            }
            case "CoreDEFENCE" -> {
                System.out.println("Which Row? (1 or 2)");
                int rowChoice = input.nextInt();
                if(board_Grid[rowChoice][colChoice] == null) { // only 1,1 2,0 2,2
                    board_Grid[rowChoice][colChoice] = new Positions(CoreDEFENCE, fromHand);

                    int atk = board_Grid[rowChoice][colChoice].getAtk();
                    int def = board_Grid[rowChoice][colChoice].getDef();
                    getCDefRow()[0] = getCDefRow()[0] + atk;
                    getCDefRow()[1] = getCDefRow()[1] + def;
                }
            }
            case "CORE" -> {
                if(board_Grid[2][1] == null){
                    board_Grid[2][1] = new Positions(CORE, fromHand);

                    int atk = board_Grid[2][1].getAtk();
                    int def = board_Grid[2][1].getDef();
                    getCoreBlock()[0] = atk;
                    getCoreBlock()[1] = def;
                }
            }
            case "DEFENCE" -> {
                if(board_Grid[3][colChoice] == null){
                    board_Grid[3][colChoice] = new Positions(DEFENCE, fromHand);

                    int atk = board_Grid[3][colChoice].getAtk();
                    int def = board_Grid[3][colChoice].getDef();
                    getDefRow()[0] = getDefRow()[0] + atk;
                    getDefRow()[1] = getDefRow()[1] + def;
                }
            }
        }
    }
public void removeFromSlots(String name, int posIndex) {
        switch (name) {
            case "UBER" -> {
                getUberRow()[0] = getUberRow()[0] - board_Grid[0][posIndex].getAtk();
                getUberRow()[1] = getUberRow()[1] - board_Grid[0][posIndex].getDef();

                board_Grid[0][posIndex] = null;
            }
            case "ATTACK" -> {
                getAtkRow()[0] = getAtkRow()[0] - board_Grid[1][posIndex].getAtk();
                getAtkRow()[1] = getAtkRow()[1] - board_Grid[1][posIndex].getDef();

                board_Grid[1][posIndex] = null;
            } //only 0 and 2 are valid
            case "CoreDEFENCE" -> {
                Scanner input = new Scanner(System.in);
                System.out.println("Which row? 1 or 2");
                int rowSelect = input.nextInt();

                getCDefRow()[0] = getCDefRow()[0] - board_Grid[posIndex][rowSelect].getAtk();
                getCDefRow()[1] = getCDefRow()[1] - board_Grid[posIndex][rowSelect].getDef();

                board_Grid[posIndex][rowSelect] = null; // only 0 and 2 are valid for row 2 and 1 is valid row 1
            }
            case "CORE" ->{
                getCoreBlock()[0] = getCoreBlock()[0] - board_Grid[2][1].getAtk();
                getCoreBlock()[1] = getCoreBlock()[1] - board_Grid[2][1].getDef();

                board_Grid[2][1] = null;
            }// only 1 is valid
            case "DEFENCE" ->{
                getDefRow()[0] = getDefRow()[0] - board_Grid[3][posIndex].getAtk();
                getDefRow()[1] = getDefRow()[1] - board_Grid[3][posIndex].getDef();

                board_Grid[3][posIndex] = null;
            }
        }

    }

//3,2,3,1,3
//UBER(), ATTACK(), CoreDEFENCE(), CORE(),DEFENCE()
//Board_Positions(int openSlots){}

for(int f = 0; f < 2; f++){
            for(int r = 0; r < 3; r++){
                if(board_Grid[0][r] != null){
                    if(f == 0) {
                        uberRow[f] = uberRow[f] + board_Grid[0][r].getAtk();
                    } else{
                        uberRow[f] = uberRow[f] + board_Grid[0][r].getDef();
                    }
                }
                if(enemy.getGrid()[0][r] != null){
                    if(f == 0) {
                        enemy.getUberRow()[f] = enemy.getUberRow()[f] + enemy.getGrid()[0][r].getAtk();
                    } else{
                        enemy.getUberRow()[f] = enemy.getUberRow()[f] + enemy.getGrid()[0][r].getDef();
                    }
                }

                if(board_Grid[3][r] != null){
                    if(f == 0) {
                        defRow[f] = defRow[f] + board_Grid[3][r].getAtk();
                    } else{
                        defRow[f] = defRow[f] + board_Grid[3][r].getDef();
                    }
                }
                if(enemy.getGrid()[3][r] != null){
                    if(f == 0) {
                        enemy.getDefRow()[f] = enemy.getDefRow()[f] + enemy.getGrid()[3][r].getAtk();
                    } else{
                        enemy.getDefRow()[f] = enemy.getDefRow()[f] + enemy.getGrid()[3][r].getDef();
                    }
                }

            }
        }
        if(board_Grid[1][0] != null){
            atkRow[0] = atkRow[0] + board_Grid[1][0].getAtk();
            atkRow[1] = atkRow[1] +board_Grid[1][0].getDef();
        }
        if(board_Grid[1][2] != null){
            atkRow[0] = atkRow[0] + board_Grid[1][2].getAtk();
            atkRow[1] = atkRow[1] + board_Grid[1][2].getDef();
        }
        if(enemy.getGrid()[1][0] != null){
            enemy.getAtkRow()[0] = enemy.getGrid()[1][0].getAtk() + enemy.getAtkRow()[0];
            enemy.getAtkRow()[1] = enemy.getGrid()[1][0].getDef() + enemy.getAtkRow()[1];
        }
        if(enemy.getGrid()[1][2] != null){
            enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + enemy.getGrid()[1][2].getAtk();
            enemy.getAtkRow()[1] = enemy.getAtkRow()[1] + enemy.getGrid()[1][2].getDef();
        }

        if(board_Grid[1][1] != null) {
            cDefRow[0] = board_Grid[1][1].getAtk() + cDefRow[0];
            cDefRow[1] = board_Grid[1][1].getDef() + cDefRow[1];
        }
        if(board_Grid[2][0] != null){
            cDefRow[0] = board_Grid[2][0].getAtk() + cDefRow[0];
            cDefRow[1] = board_Grid[2][0].getDef() + cDefRow[1];
        }
        if(board_Grid[2][2] != null){
            cDefRow[0] = cDefRow[0] + board_Grid[2][2].getAtk();
            cDefRow[1] = cDefRow[1] + board_Grid[2][2].getDef();
        }
        if(enemy.getGrid()[1][1] != null) {
            enemy.getCDefRow()[0] = enemy.getGrid()[1][1].getAtk() + enemy.getCDefRow()[0];
            enemy.getCDefRow()[1] = enemy.getGrid()[1][1].getDef() + enemy.getCDefRow()[1];
        }
        if(enemy.getGrid()[2][0] != null){
            enemy.getCDefRow()[0] = enemy.getGrid()[2][0].getAtk() + enemy.getCDefRow()[0];
            enemy.getCDefRow()[1] = enemy.getGrid()[2][0].getDef() + enemy.getCDefRow()[1];
        }
        if(enemy.getGrid()[2][2] != null){
            enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + enemy.getGrid()[2][2].getAtk();
            enemy.getCDefRow()[1] = enemy.getCDefRow()[1] + enemy.getGrid()[2][2].getDef();
        }

        if(board_Grid[2][1] != null){
            coreBlock[0] = board_Grid[2][1].getAtk();
            coreBlock[1] = board_Grid[2][1].getDef();
        }
        if(enemy.getGrid()[2][1] != null) {
            enemy.getCoreBlock()[0] = enemy.getGrid()[2][1].getAtk();
            enemy.getCoreBlock()[1] = enemy.getGrid()[2][1].getDef();
        }

        try(FileReader modReader = new FileReader("../src/Game/CardData/Modifier.json")) {

if(current.getBoard().hasBuild()) {
        System.out.println(current.getBoard().getCurrentBuild().getItemName());
        System.out.println("Do you want to remove Build effects? (y/n)");
        String useBuild = input.nextLine();
        if(useBuild.equals("y")){ current.getBoard().removeBuild();}

    } else {
        //ComboBuild availableBuild = current.getBoard().showValidBuilds(current.getBoard());
        current.getBoard().showValidBuilds(current.getBoard());
        System.out.println("use build? (y/n)");
        String b = input.nextLine();
        if(b.equals("y")) {
            System.out.println("which build? (0,1,2...)");
            int useBuild = input.nextInt();
            ComboBuild availableBuild = current.getBoard().getPossibleBuilds().get(useBuild);
            availableBuild.useBuild();
            current.getBoard().addBuild(availableBuild);
        }

    }
}

public void showValidBuilds(Board playerBoard) throws IOException {
        int checkResults = 0;

        if(playerBoard.hasBuild()){
//            return playerBoard.getCurrentBuild();
            System.out.println("Ye no");
            return;
        }

        try(BufferedReader modReader = new BufferedReader(new InputStreamReader(
                Main.class.getResourceAsStream("CardData/Formation_Recipes[OLD].json")))) {
            StringBuilder recipeString = new StringBuilder(" ");
            int i;
            while ((i = modReader.read()) != -1) {
                //System.out.print((char)i);
                recipeString.append((char) i);
            }
            JSONObject jsonMODObject = new JSONObject(recipeString.toString());
            JSONArray cookBook = (JSONArray) jsonMODObject.get("recipe_List");

            for(int j = 0; j < cookBook.length(); j++ ){
                JSONObject tmpRecipe = cookBook.getJSONObject(j);
                JSONArray recipeIngredients = tmpRecipe.getJSONArray("ingredients");

                for(int k = 0; k < recipeIngredients.length(); k++){
                    JSONObject tmpIngredients = recipeIngredients.getJSONObject(k);

                    boolean stepTreat = tmpIngredients.getBoolean("getCard");

                    boolean needCard = tmpIngredients.getBoolean("cardCheck");
                    boolean needType = tmpIngredients.getBoolean("typeCheck");
                    JSONArray getPos = tmpIngredients.getJSONArray("position");

                    if(!needCard && !stepTreat && needType){
                        String tmpType = tmpIngredients.getString("type");

                        for(int l = 0; l < getPos.length(); l++){
                            JSONObject tmpPos = getPos.getJSONObject(l);

                            boolean needMorePoints = tmpPos.getBoolean("additionalPoints");
                            if(!needMorePoints){
                                String pName = tmpPos.getString("posName");
                                //switch to the corresponding row for the posName to check the types
                                switch(pName) {
                                    default -> System.exit(1);
                                    case "UBER" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[0][p].getSlot().activeTypeOne().equals(tmpType)) {
                                                checkResults++; // log the correct the go check others
                                            }
                                        }
                                    }
                                    case "ATTACK" -> {
                                        if (playerBoard.getGrid()[1][0].getSlot().activeTypeOne().equals(tmpType) || playerBoard.getGrid()[1][2].getSlot().activeTypeOne().equals(tmpType)) {
                                            checkResults++; // log the correct the go check others
                                        }
                                    }
                                    case "CoreDEFENCE" -> {
                                        if (playerBoard.getGrid()[1][1].getSlot().activeTypeOne().equals(tmpType) || playerBoard.getGrid()[2][0].getSlot().activeTypeOne().equals(tmpType) || playerBoard.getGrid()[2][2].getSlot().activeTypeOne().equals(tmpType)) {
                                            checkResults++; // log the correct the go check others
                                        }
                                    }
                                    case "CORE" -> {
                                        if (playerBoard.getGrid()[2][1].getSlot().activeTypeOne().equals(tmpType)) {
                                            checkResults++;
                                        }
                                    }
                                    case "DEFENCE" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[3][p].getSlot().activeTypeOne().equals(tmpType)) {
                                                checkResults++; // log the correct the go check others
                                            }
                                        }
                                    }
//
                                }

                            }
                            //points just add to the card ig

                        }
                        //where results were

                    }else if(needCard && !stepTreat && !needType){
                        int tmpID = tmpIngredients.getInt("cardID");

                        for(int l = 0; l < getPos.length(); l++){
                            JSONObject tmpPos = getPos.getJSONObject(l);

                            boolean needMorePoints = tmpPos.getBoolean("additionalPoints");
                            String pName = tmpPos.getString("posName");
                            if(!needMorePoints){
                                //switch to the corresponding row for the posName to check the types
                                switch(pName) {
                                    default -> System.exit(1);
                                    case "UBER" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[0][p].getSlot().getId() == tmpID) {
                                                checkResults++; // log the correct the go check others
                                            }
                                        }
                                    }
                                    case "ATTACK" -> {
                                        if (playerBoard.getGrid()[1][0].getSlot().getId() == tmpID || playerBoard.getGrid()[1][2].getSlot().getId() == tmpID) {
                                            checkResults++; // log the correct the go check others
                                        }
                                    }
                                    case "CoreDEFENCE" -> {
                                        if (playerBoard.getGrid()[1][1].getSlot().getId() == tmpID || playerBoard.getGrid()[2][0].getSlot().getId() == tmpID || playerBoard.getGrid()[2][2].getSlot().getId() == tmpID) {
                                            checkResults++; // log the correct the go check others
                                        }
                                    }
                                    case "CORE" -> {
                                        if (playerBoard.getGrid()[2][1].getSlot().getId() == tmpID) {
                                            checkResults++;
                                        }
                                    }
                                    case "DEFENCE" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[3][p].getSlot().getId() == tmpID) {
                                                checkResults++; // log the correct the go check others
                                            }
                                        }
                                    }
//                                playerBoard.board_Grid[][].currentPlace();
                                }
                            } else {
                                int extraPoints = tmpPos.getInt("ePoints");
                                //switch to the corresponding row for the posName to check the types
                                switch(pName) {
                                    default -> System.exit(1);
                                    case "UBER" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[0][p].getSlot().getId() == tmpID) {
                                                checkResults++; // log the correct the go check others
                                                playerBoard.getUberRow()[0] = playerBoard.getUberRow()[0] + extraPoints;
                                                playerBoard.getUberRow()[1] = playerBoard.getUberRow()[1] + extraPoints;
                                            }
                                        }
                                    }
                                    case "ATTACK" -> {
                                        if (playerBoard.getGrid()[1][0].getSlot().getId() == tmpID ) {
                                            checkResults++; // log the correct the go check others
                                            playerBoard.getAtkRow()[0] = playerBoard.getAtkRow()[0] + extraPoints;
                                            playerBoard.getAtkRow()[1] = playerBoard.getAtkRow()[1] + extraPoints;
                                        } else if(playerBoard.getGrid()[1][2].getSlot().getId() == tmpID){
                                            checkResults++;
                                            playerBoard.getAtkRow()[0] = playerBoard.getAtkRow()[0] + extraPoints;
                                            playerBoard.getAtkRow()[1] = playerBoard.getAtkRow()[1] + extraPoints;
                                        }
                                    }
                                    case "CoreDEFENCE" -> {
                                        if (playerBoard.getGrid()[1][1].getSlot().getId() == tmpID ) {
                                            checkResults++; // log the correct the go check others
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        } else if(playerBoard.getGrid()[2][0].getSlot().getId() == tmpID){
                                            checkResults++;
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        } else if(playerBoard.getGrid()[2][2].getSlot().getId() == tmpID){
                                            checkResults++;
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        }
                                    }
                                    case "CORE" -> {
                                        if (playerBoard.getGrid()[2][1].getSlot().getId() == tmpID) {
                                            checkResults++;
                                            playerBoard.getCoreBlock()[0] = playerBoard.getCoreBlock()[0] + extraPoints;
                                            playerBoard.getCoreBlock()[1] = playerBoard.getCoreBlock()[1] + extraPoints;
                                        }
                                    }
                                    case "DEFENCE" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[3][p].getSlot().getId() == tmpID) {
                                                checkResults++; // log the correct the go check others
                                                playerBoard.getDefRow()[0] = playerBoard.getDefRow()[0] + extraPoints;
                                                playerBoard.getDefRow()[1] = playerBoard.getDefRow()[1] + extraPoints;
                                            }
                                        }
                                    }
                                }
                            }

                        }
                       //where results were

                    }else if(stepTreat && !needCard && !needType){
                        for(int l = 0; l < getPos.length(); l++){
                            JSONObject tmpPos = getPos.getJSONObject(l);
                            ArrayList<Card> cardStack = new ArrayList<>();

                            boolean needMorePoints = tmpPos.getBoolean("additionalPoints");
                            String pName = tmpPos.getString("posName");

                            if(!needMorePoints){
                                //switch to the corresponding row for the posName to check the types
                                switch(pName) {
                                    default -> System.exit(1);
                                    case "UBER" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[0][p] != null) {
                                                //checkResults++; // log the correct the go check others
                                                cardStack.add(playerBoard.getGrid()[0][p].getSlot());
                                            }
                                        }
                                    }
                                    case "ATTACK" -> {
                                        if (playerBoard.getGrid()[1][0] != null ) {
                                            cardStack.add(playerBoard.getGrid()[1][0].getSlot());
                                        } else if(playerBoard.getGrid()[1][2] != null){
                                            cardStack.add(playerBoard.getGrid()[1][2].getSlot());
                                        }
                                    }
                                    case "CoreDEFENCE" -> {
                                        if (playerBoard.getGrid()[1][1] != null) {
                                            cardStack.add(playerBoard.getGrid()[1][1].getSlot());
                                        } else if( playerBoard.getGrid()[2][0] != null ){
                                            cardStack.add(playerBoard.getGrid()[2][0].getSlot());
                                        }else if(playerBoard.getGrid()[2][2] != null){
                                            cardStack.add(playerBoard.getGrid()[2][2].getSlot());
                                        }
                                    }
                                    case "CORE" -> {
                                        if (playerBoard.getGrid()[2][1] != null) {
                                            cardStack.add(playerBoard.getGrid()[2][1].getSlot());
                                        }
                                    }
                                    case "DEFENCE" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[3][p] != null) {
                                                cardStack.add(playerBoard.getGrid()[3][p].getSlot());
                                            }
                                        }
                                    }
//                                playerBoard.board_Grid[][].currentPlace();
                                }

                                for (Card card : cardStack) {
                                    Card x = cardStack.get(0);
                                    if (x.getId() == card.getId()) {
                                        checkResults++;
                                    }
                                }
                                JSONObject getResult = tmpRecipe.getJSONObject("result");
                                int r = getResult.getInt("passNum");
                                if(checkResults == r){
                                    int buildID = tmpRecipe.getInt("formID");
                                    cardDatabase fd = new cardDatabase();
                                    for(ComboBuild x: fd.formPack){
                                        if(x.getId() == buildID){
                                            System.out.println(x.getItemName());
                                            playerBoard.getPossibleBuilds().add(x);
                                        }
                                    }
                                }

                            } else {
                                int extraPoints = tmpPos.getInt("ePoints");
                                //switch to the corresponding row for the posName to check the types
                                switch(pName) {
                                    default -> System.exit(1);
                                    case "UBER" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[0][p] != null) {
                                                //checkResults++; // log the correct the go check others
                                                cardStack.add(playerBoard.getGrid()[0][p].getSlot());
                                                playerBoard.getUberRow()[0] = playerBoard.getUberRow()[0] + extraPoints;
                                                playerBoard.getUberRow()[1] = playerBoard.getUberRow()[1] + extraPoints;
                                            }
                                        }
                                    }
                                    case "ATTACK" -> {
                                        if (playerBoard.getGrid()[1][0] != null ) {
                                            cardStack.add(playerBoard.getGrid()[1][0].getSlot());
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        } else if(playerBoard.getGrid()[1][2] != null){
                                            cardStack.add(playerBoard.getGrid()[1][2].getSlot());
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        }
                                    }
                                    case "CoreDEFENCE" -> {
                                        if (playerBoard.getGrid()[1][1] != null) {
                                            cardStack.add(playerBoard.getGrid()[1][1].getSlot());
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        } else if( playerBoard.getGrid()[2][0] != null ){
                                            cardStack.add(playerBoard.getGrid()[2][0].getSlot());
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        }else if(playerBoard.getGrid()[2][2] != null){
                                            cardStack.add(playerBoard.getGrid()[2][2].getSlot());
                                            playerBoard.getCDefRow()[0] = playerBoard.getCDefRow()[0] + extraPoints;
                                            playerBoard.getCDefRow()[1] = playerBoard.getCDefRow()[1] + extraPoints;
                                        }
                                    }
                                    case "CORE" -> {
                                        if (playerBoard.getGrid()[2][1] != null) {
                                            cardStack.add(playerBoard.getGrid()[2][1].getSlot());
                                            playerBoard.getCoreBlock()[0] = playerBoard.getCoreBlock()[0] + extraPoints;
                                            playerBoard.getCoreBlock()[1] = playerBoard.getCoreBlock()[1] + extraPoints;
                                        }
                                    }
                                    case "DEFENCE" -> {
                                        for (int p = 0; p < 3; p++) {
                                            if (playerBoard.getGrid()[3][p] != null) {
                                                cardStack.add(playerBoard.getGrid()[3][p].getSlot());
                                                playerBoard.getDefRow()[0] = playerBoard.getDefRow()[0] + extraPoints;
                                                playerBoard.getDefRow()[1] = playerBoard.getDefRow()[1] + extraPoints;
                                            }
                                        }
                                    }
                                }

                                for (Card card : cardStack) {
                                    Card x = cardStack.get(0);
                                    if (x.getId() == card.getId()) {
                                        checkResults++;
                                    }
                                }
                               //where results was
                            }
                            //points just add to the bundles

                        }
                    }

                    JSONObject getResult = tmpRecipe.getJSONObject("result");
                    int r = getResult.getInt("passNum");
                    if(checkResults == r){
                        int buildID = tmpRecipe.getInt("formID");
                        cardDatabase fd = new cardDatabase();
                        for(ComboBuild x: fd.formPack){
                            if(x.getId() == buildID){
                                System.out.println(x.getItemName());
                                playerBoard.getPossibleBuilds().add(x);
                            }
                        }
                    }
                }

            }

        } catch (IOException ex){
            throw new IOException("Something Has Failed");

        } finally {
            System.out.println("The results are as seen above... tread lightly");
        }

        //return playerBoard.hasBuild();
    }

int overflowP1, overflowP2;
overflowP2 = uberRow[1] - enemy.getUberRow()[0]; // uber gets no overflow
overflowP1 = enemy.getUberRow()[1] - uberRow[0]; //p1 remainder from subtracting atk from enemy def
int tmp1, tmp2; // the overflow goes once, so it needs to reset after

if(overflowP1 > 0){
    atkRow[0] = atkRow[0] + overflowP1;
}
tmp1 = overflowP1;
if(overflowP2 > 0){
    enemy.getAtkRow()[0] = enemy.getAtkRow()[0] + overflowP2;
}
tmp2 = overflowP2;

overflowP2 = atkRow[1] - (enemy.getAtkRow()[0] - tmp2);
overflowP1 = enemy.getAtkRow()[1] - (atkRow[0] - tmp1) ;
if(overflowP1 > 0){
    cDefRow[0] = cDefRow[0] + overflowP1;
}
tmp1 = overflowP1;
if(overflowP2 > 0){
    enemy.getCDefRow()[0] = enemy.getCDefRow()[0] + overflowP2;
}
tmp2 = overflowP2;

overflowP2 = cDefRow[1] - (enemy.getCDefRow()[0] - tmp2);
overflowP1 = enemy.getCDefRow()[1] - (cDefRow[0] - tmp1);
if(overflowP1 > 0){
    defRow[0] = defRow[0] + overflowP1;
}
if(overflowP2 > 0){
    enemy.getDefRow()[0] = enemy.getDefRow()[0] + overflowP2;
}

 /*
        switch (name) {
            case "UBER" -> {
                //for each uber position on the grid //if there are less than uber open slot amount of uber positions
                if(board_Grid[0][colChoice] == null){
                    board_Grid[0][colChoice] = new Positions(UBER, fromHand);

                    int atk = board_Grid[0][colChoice].getAtk();
                    int def =board_Grid[0][colChoice].getDef();
                    getUberRow()[0] = getUberRow()[0] + atk;
                    getUberRow()[1] = getUberRow()[1] + def;
                }
            }
            case "ATTACK" -> {
                if(board_Grid[1][colChoice] == null ){ // only col 0 & 2
                    board_Grid[1][colChoice] = new Positions(ATTACK, fromHand);

                    int atk = board_Grid[1][colChoice].getAtk();
                    int def = board_Grid[1][colChoice].getDef();
                    getAtkRow()[0] = getAtkRow()[0] + atk;
                    getAtkRow()[1] = getAtkRow()[1] + def;
                }
            }
            case "CoreDEFENCE" -> {
                System.out.println("Which Row? (1 or 2)");
                int rowChoice = input.nextInt();
                if(board_Grid[rowChoice][colChoice] == null) { // only 1,1 2,0 2,2
                    board_Grid[rowChoice][colChoice] = new Positions(CoreDEFENCE, fromHand);

                    int atk = board_Grid[rowChoice][colChoice].getAtk();
                    int def = board_Grid[rowChoice][colChoice].getDef();
                    getCDefRow()[0] = getCDefRow()[0] + atk;
                    getCDefRow()[1] = getCDefRow()[1] + def;
                }
            }
            case "CORE" -> {
                if(board_Grid[2][1] == null){
                    board_Grid[2][1] = new Positions(CORE, fromHand);

                    int atk = board_Grid[2][1].getAtk();
                    int def = board_Grid[2][1].getDef();
                    getCoreBlock()[0] = atk;
                    getCoreBlock()[1] = def;
                }
            }
            case "DEFENCE" -> {
                if(board_Grid[3][colChoice] == null){
                    board_Grid[3][colChoice] = new Positions(DEFENCE, fromHand);

                    int atk = board_Grid[3][colChoice].getAtk();
                    int def = board_Grid[3][colChoice].getDef();
                    getDefRow()[0] = getDefRow()[0] + atk;
                    getDefRow()[1] = getDefRow()[1] + def;
                }
            }
        }         */
 /*switch (name) {
            case "UBER" -> {
                getUberRow()[0] = getUberRow()[0] - board_Grid[0][posIndex].getAtk();
                getUberRow()[1] = getUberRow()[1] - board_Grid[0][posIndex].getDef();

                board_Grid[0][posIndex] = null;
            }
            case "ATTACK" -> {
                getAtkRow()[0] = getAtkRow()[0] - board_Grid[1][posIndex].getAtk();
                getAtkRow()[1] = getAtkRow()[1] - board_Grid[1][posIndex].getDef();

                board_Grid[1][posIndex] = null;
            } //only 0 and 2 are valid
            case "CoreDEFENCE" -> {
                Scanner input = new Scanner(System.in);
                System.out.println("Which row? 1 or 2");
                int rowSelect = input.nextInt();

                getCDefRow()[0] = getCDefRow()[0] - board_Grid[posIndex][rowSelect].getAtk();
                getCDefRow()[1] = getCDefRow()[1] - board_Grid[posIndex][rowSelect].getDef();

                board_Grid[posIndex][rowSelect] = null; // only 0 and 2 are valid for row 2 and 1 is valid row 1
            }
            case "CORE" ->{
                getCoreBlock()[0] = getCoreBlock()[0] - board_Grid[2][1].getAtk();
                getCoreBlock()[1] = getCoreBlock()[1] - board_Grid[2][1].getDef();

                board_Grid[2][1] = null;
            }// only 1 is valid
            case "DEFENCE" ->{
                getDefRow()[0] = getDefRow()[0] - board_Grid[3][posIndex].getAtk();
                getDefRow()[1] = getDefRow()[1] - board_Grid[3][posIndex].getDef();

                board_Grid[3][posIndex] = null;
            }
        }         */

#board_1 button, #board_2 button{
    /* margin: 5px; */
    /* padding: 5px; */

    font-family: "Jacquarda Bastarda 9", serif;
    font-size: 15pt;
    background-color: gray;
    float: left;
    border: none;
    border-radius: 15px;
    box-shadow: 0 9px #999;
}
#board_1 button:active, #board_2 button:active{
    box-shadow: 0 5px #666;
    transform: translateY(4px);
}
#board_1 button:hover, #board_2 button:hover{
    background-color: white;
}


let v = $(this).attr("src");
$(".slot").on("click", function(){
$(this).attr("src", v);
})

<button class = "button"> Discard [Hand] </button>
<button class = "button"> Discard [Board] </button>

function testTst() {
   let ciD = Math.floor(Math.random() * 42);
   console.log(ciD);
   var myCardAPI = "../src/Game/CardData/card_image.json";
   //myCardAPI.html(JSON.stringify(getJSON));
   $.getJSON( myCardAPI, {
     tags: "cardList name",
     tagmode: "any",
     format: "json"
   })
     .done(function( data ) {
//        JSON.stringify(getJSON(myCardAPI));
       $.each( data, function(i, data) {
         //$( "<img>" ).attr( "src", data.imageID ).appendTo( ".hand" );
         console.log(data);
       });

     });
}
function parser(){ //fullPrompt, cb
    let cdataURL = '../src/Game/CardData/card_image.json';
    $.ajax({
        url: cdataURL,
        contentType: "application/json",
        data: JSON.stringify("{" + cdataURL + "}"),
        dataType: "json"
    })
    .done(function(data){
        console.log(data.cardList[0].imageID);
        $("#1").attr("src", data.cardList[0].imageID);
    });
}
function ttt() {
     $("#hand_1 img").selectable({
       stop: function() {
         var result = $(".slot img").click;
         $( "#hand_1 img", this ).each(function() {
           var index = $( "#hand_1 img" ).attr( "src" );
           result.attr( "src", index  );
         });
       }
     });
}
function tt() {
       $('a.popper').hover(function() {
           $("img").remove();
           $('.pop').toggle();
       });
   }
$("#hand_2 img").on('click', function(){
       let re = $(this).attr("src");
       $("#otherPlayer .slot img").on('click', function(){
           $(this).attr("src", re);
       })
  })

// Generated JS from Java: Game.Slots.Positions -----
function Game_Slots_Positions(type, inPlay) {
    this.fromHand = null;
    this.onTable = null;

    jv_Object.call(this);
    this._Game_Slots_PositionsInit();
    this.fromHand = inPlay;
    this.onTable = type;
}

var Game_Slots_Positions_c = sc_newClass("Game.Slots.Positions", Game_Slots_Positions, jv_Object, null);

Game_Slots_Positions_c.toString = function ()  {
    if (this.hasOwnProperty("$protoName")) {
        return jv_Class_c.toString.apply(this, arguments);
    }
    return this.fromHand.toString();
};
Game_Slots_Positions_c.currentPlace = function ()  {
    return this.onTable;
};
Game_Slots_Positions_c.getStats = function ()  {
    return this.fromHand.getValue(this.onTable);
};
Game_Slots_Positions_c.getAtk = function ()  {
    return this.fromHand.getValue(this.onTable)[0];
};
Game_Slots_Positions_c.getDef = function ()  {
    return this.fromHand.getValue(this.onTable)[1];
};
Game_Slots_Positions_c.getSlot = function ()  {
    return this.fromHand;
};
Game_Slots_Positions_c.remove = function ()  {
    this.fromHand = null;
};
Game_Slots_Positions_c.isEmpty = function ()  {
    return this.fromHand === null;
};

Game_Slots_Positions_c._Game_Slots_PositionsInit = function() {
};

switch(isCard + "-" + isSpecificCard + "-" + isType){
    case "true-false-false": {
        for(int o = 0; o < exchangeBin.size(); o++){
            //check if the card appears the number of times
            Card x = exchangeBin.get(o);
            for(int r = 1; r < exchangeBin.size()-1; r++){
                if(x.getId() == exchangeBin.get(r).getId()){

                }
            }
        }
    }
    case "false-true-false": System.exit(1);
    case "false-false-true": System.exit(2);
    case "true-false-true": System.exit(3);
    default: throw new RuntimeException("something strange happening here");
}

Map<ComboBuild, Map<Card,Integer>> checkCards = new HashMap<>();
Map<Card, Integer> countNumCards = new HashMap<>();
Map<String, Integer> typeToNum = new HashMap<>();
Map<Integer, Integer> IDToNumCards = new HashMap<>();
//if the combo needs 2 maps just run them twice in whatever order